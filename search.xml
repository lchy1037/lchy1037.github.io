<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书笔记-Face Image Quality Assessment Based on Learning to Rank(by Jiansheng Chen)]]></title>
    <url>%2F2017%2F07%2F13%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Face-Image-Quality-Assessment-Based-on-Learning-to-Rank-JianshengChen%2F</url>
    <content type="text"><![CDATA[记录阅读 Jiansheng Chen 的论文 “Face Image Quality Assessment Based on Learning to Rank” 的感想。 摘要人脸图像质量是人脸识别准确性的重要影响因素之一。在实际识别系统中通常会抓取到不同场景下的多张人脸，从多张人脸图像中选择一张高质量图像去识别对提高系统的性能是非常有用的策略。本文提出了一种基于 learning to rank 的框架去评估人脸图像质量。这种方法很简单，并且能够自适应不同的识别方法。实验结果证明了它在提高人脸检测及识别的鲁棒性上非常有效。 1. 介绍对个人身份验证来说，人脸被普遍认为是一种理想的生物识别特征，因为它是普遍的、有区别的、非侵入式的并且容易获取。在过去的二十年，自动人脸识别技术吸引了大量的关注，不管是学术界还是工业界，提出了很多基于人脸图像的人脸识别 (identifying) 和身份认证 (verifying) 方法。然而，人脸识别仍是一项富有挑战性的任务，因为在自然环境下采集的人脸图像会由于光照、姿态、遮挡、表情的不同产生不同的图像。这些问题在实际的应用程序中会由于不配合的用户以及不可控的环境造成非常严重的影响。虽然很多提出了很多方法来提高人脸识别的鲁棒性去对抗不同质量的人脸图像，但普遍认为人脸识别还是在高质量人脸图像上表现出更好的性能。 2. 人脸标准化仅仅位于人脸内部的像素点应该用来评估人脸质量。这可以实现，比如，通过定位人脸轮廓的标志点，图像中的每张脸可以产生一个特殊的标注。然而，这很耗时，并且由于不规则的轮廓，对后面的特征提取造成很大的困难。另一方面，许多人脸检测器简单的输出方形包围框，这明显偏离了人脸的轮廓，并且涵盖了大量的非人脸信息。此外，面部旋转也应该作为质量评估的影响因素之一，因为很多人脸识别系统都能够处理。基于上述所有的考虑，本文提出了人脸标准化过程，见 Fig.1. Fig.1(a) 展示了人脸检测的结果，该人脸来自 LFW 人脸数据集。然后将检测到的人脸区域调整到 $68\times68$ 像素，输入一个 CNN 网络来获取标志点位置。本文用眼角和嘴角，因为这些点可以清晰的标注，并且涵盖的区域包含了人脸的大部分区域。Fig.2 展示了 CNN 的网络结构，它包含了三个卷积层以及三个降采样层，卷积核是 $5\times5$，输出是标志点坐标。本文从 LFW 数据集中随机选择了 10000 幅图像用来训练，剩下的用来测试。在测试集上，标志点的位置偏差平均是 1.4 个像素。Fig.1(b) 显示了标注的标志点。 为了标准化人脸区域，并且消除旋转的影响，本文首先计算中心点 $C$ 以及用 linear time algorithm 方法得到的涵盖所有标志点的最小的圆的半径 $r$。然后以点 $C$ 为中心取一个大小为 $2.4r\times4r$ 的矩形 $R$ (见图Fig.1(c))。显然所有的标志点都包含在 $R$ 中。设四个眼角的坐标是 $[x_i, y_i], (i = 1,2,3,4)$，矩形的方向由公式 $(1)$ 决定，这样矩形 $R$ 的宽平行于四个眼角构成的直线。Fig.1(d) 中的标准脸就可以由矩形区域 $R$ 围绕 $C$ 旋转 $\theta$ 角得到。 $$\theta = \arctan(\frac{\sum_{i=1}^{4} {x_iyi} - 4\overline{x}\overline{y}}{\sum{i=1}^{4} {x_i^2} - 4{\overline{x}}^2})$$(1) 其中 $\overline{x}$ 和 $\overline{y}$ 分别表示水平和垂直方向的均值。 更多的 LFW 图像的标准化结果如图 Fig.1(e)(f)(g)，可以看到标准化的脸更紧凑，并确保包含了人脸的主要部分。标准化过后的脸之后被用于人脸质量评估的输入。这个标准化方法对于一些不准确的标志点来说是有点健壮的。然而，当出现多个标志点位置不准确的情况，标准化的结果可能会恶化，并导致人脸质量评估的结果效果很差。然而这个问题是可以容忍的，因为这大多数情况下，这种情况确实表明人脸图像的质量很低。 3. 人脸质量评价一般很难精确的定义量化人脸图像质量。在过去的研究中，解决此问题主要有两种方案。第一种是利用面部的一些特性，比如分辨率、姿态角度、或者光照参数，利用这些去量化人脸图像质量；另一种是选择一张“标准脸”，用人脸图像与这张“标准脸”的差异来度量人脸质量。这两种方法都比较僵化，缺乏适用性，因为它们都没有考虑人脸识别方法可能带来的差异。比如有一种人脸识别算法适用于解决遮挡问题，那么 Fig.1(g) 可能比 Fig.1(f) 表现的更好。相反的，有一种人脸识别算法适用于解决姿态问题，则 Fig.1(f) 具有更高的图像质量。因此，要以相对的方式去考虑人脸图像质量。对大多数人脸识别方法，考虑图像质量，Fig.1(d) 比 Fig.1(f) 要好，但是比 Fig.1(e) 要差。 基于上述的考虑，本文提出了一种基于 learning to rank 的简单的、灵活的人脸图像质量评价方法。假设有一种人脸识别方法在两个不同的数据集 $A$ 和 $B$ 中测试，且识别的性能在 $A$ 上表现比 $B$ 好。这表明，对这种人脸识别方法，$A$ 中的图像比 $B$ 中的有更高的质量。我们标记这为 $A\succ B$，设 $I_i$ 和 $I_j$ 分别表示 $A$ 和 $B$ 中的一幅图像，$f()$ 表示将提取图像特征向量的函数，定义一种线性结构的质量评价函数 $S(I) = \omega^{T}f(I)$，目标就是求权重 $\omega$ 的值，使得其满足方程 $(2)$ 的约束。同时，在同一个人脸数据集中的图像应该具有相同的质量，这通过方程 $(3)\;(4)$ 来约束，本文称 $S(I)$ 的值为图像 $I$ 的 $RQS(Rank \; based \; Quality \; Score)$。 $$\omega^{T}f(I_i) &gt; \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{B}$$(2)$$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{A}$$(3)$$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{B},\;\forall{I_j}\in{B}$$(4) 上述问题规划与文献 [23] 中的相同，因此可以转化为一个凸规划问题（见公式(5)），通过引入非负松弛变量 ${\lambda_1},\,{\lambda_2},\,{\lambda_3}$ 来平衡相关约束，由公式 (5) 定义的优化问题可以用 Newton 方法有效的解决。 $$minmize(|{\omega^T}|_2^2 + {\lambda1}{\sum{\xi{ij}^2}} + {\lambda2}{\sum{\eta{ij}^2}} + {\lambda3}{\sum{\gamma{ij}^2}})$$$$s.t.\quad {\omega^T(f(I_i)-f(Ij))}\geq{1-\xi{ij}};\quad{\forall{I_i}\in{A},\,{\forall{I_j}\in{B}}}$$$${|\omega^T(f(I_i)-f(Ij))|}\leq{\eta{ij}},\quad{\forall{I_i}\in{A},\,{\forall{I_j}\in{A}}}$$$${|\omega^T(f(I_i)-f(Ij))|}\leq{\gamma{ij}},\quad{\forall{I_i}\in{B},\,{\forall{Ij}\in{A}}}$$$${\xi{ij}}\geq{0},\quad {\eta{ij}}\geq{0},\quad {\gamma{ij}}\geq{0}$$(5) 本文提出的公式可以扩展至多数据集、多特征。对于多特征融合，采用两层学习策略。假设从图像 $I$ 中提取了 $m$ 个不同的特征，设与第 $i$ 个特征相关的质量评价函数为 $S_i(I)={\omega^T}f_i(I),\;{(i=1,2,\cdots,m)}$。在第一层学习中，所有的排序权重 $\omega_i$ 通过公式(5)学习到，设 $\vec{S_v} = {[{S_1(I)};{S_2(I)}\;\cdots\;{S_m(I)}]}^T$ 为包含第一层学习张由图像 $I$ 所有特征得到的 $RQS$ 的列向量。定义第二层质量评估函数为 ${S_k(I)} = {\omegak}{f{\Phi}(\vec{Sv})}$，其中 $f{\Phi}()$ 为多项式核函数。本文中 $m=5$ 并且多项式核函数为二阶多项式核函数。$f_{\Phi}(\vec{S_v})$ 的表达式为公式(6)。 $\omega_k$ 的值可以通过二次训练得到，$S_k(I)$ 的值归一化到 $0~100$ 之间，并用来图像 $I$ 的最终得分。Fig.3 展示了计算 Fig.1(d) 的 $RQS$ 的计算过程。 4. 实验本文实验结果展示如图Fig.6。 5. 总结参考文献]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人脸图片质量评估]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E8%84%B8%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[人脸图像质量评估概述。 人脸图片质量评估图片质量评估 算法分为：主观的和客观的。 人脸识别系统 的流程为：输入面部图片–&gt;人脸检测–&gt;质量评估–&gt;对质量较好的进行识别(不好的丢弃) 人脸图片质量特征 纹理特征(Texture)：对比度(Contrast)，压缩比(Compression ratio)，光照强度(Illuminance) 几何特征(Geometry)：对称性(Symmetry)，姿态(Pose)，旋转角度(Rotation)，双眼之间的距离(Eye visibility) 人脸图片质量评估 是基于排序学习(Learning to rank, 简称 L2R)。 参考资料 Vladimir Khryashchev, Evaluation of Face Image Quality Metrics in Person Identification Problem Jiansheng Chen, Member, IEEE, Yu Deng, Gaocheng Bai, and Guangda Su, Face Image Quality Assessment Based on Learning to Rank]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt 界面样式设计]]></title>
    <url>%2F2017%2F07%2F06%2FC-Qt-%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Qt 开发中有两种方法来进行 UI 定制：Qt 二维绘图 (Qt 2D drawing and painting) 以及 Qt 样式表 (Qt Style Sheet)，通常这两种方法需要结合一起使用，以发挥其强大的作用。这里主要针对 Qt 样式表 (Qt Style Sheet)，对使用 Qt 设计界面和控件样式的一些方法进行总结（建议用 QSS 写界面）。 1. Qt 界面样式设计 1.1. 控件样式设计 1.1.1. QLabel 样式 1.1.2. QComboBox 1.1.3. QEditLine 1.1.4. QCheckbox 1.1.5. QPushButton 1.1.6. QScrollBar 1.1.7. QTableWidget 1.2. 参考资料 1. Qt 界面样式设计1.1. 控件样式设计改变控件的样式一般使用 setStyleSheet(“”) 函数，其可填参数如下： 参数 效果说明 “background-color: rgb(0, 0, 0);” 设置 件的背景色为 QColor(0,0,0) “background: url(:/img/label_bg.png);” 用图片填充控件 “color: rgb(255, 255, 255);” 设置控件的文本颜色为 QColor(255,255,255) “font: bold 16px;” 设置控件中的文本字体为 16 号粗体 “border: 2px solid rgb(66, 169, 235);” 设置控件的边框宽度为 2px，颜色为 QColor(66,169,235) “border-radius: 4px;” 设置控件的边角为圆角 以下仅对具体控件的特殊样式设计进行说明。 1.1.1. QLabel 样式如果 style sheet 无法满足 QLabel 在应用的需求，可通过继承 QLabel 写自己新的 label 类。比如在 QLabel 的四个角画线，显示一种画框效果，可新建一个 MyQLabel 类，在类中重写 paintEvent(QPaintEvent *event) 函数即可。代码示例如下： 1234567891011121314151617181920void MyQLabel::paintEvent(QPaintEvent *event)&#123; QLabel::paintEvent(event); // 重要，先调用父类的 paintEvent() 为了显示原背景图像 int width = this-&gt;width(); int height = this-&gt;height(); QPainter painter(this); painter.setPen(QPen(QColor(66,169,235), 3)); painter.drawLine(QPointF(0, 0), QPointF(width/8, 0)); // 左上角横线 painter.drawLine(QPointF(0, 0), QPointF(0, height/8)); // 左上角竖线 painter.drawLine(QPointF(width, 0), QPointF(width*7/8, 0)); // 右上角横线 painter.drawLine(QPointF(width, 0), QPointF(width, height/8)); // 右上角竖线 painter.drawLine(QPointF(0, height), QPointF(width/8, height)); // 左下角横线 painter.drawLine(QPointF(0, height), QPointF(0, height*7/8)); // 左下角竖线 painter.drawLine(QPointF(width, height), QPointF(width*7/8, height)); // 右下角横线 painter.drawLine(QPointF(width, height), QPointF(width, height*7/8)); // 右下角竖线&#125; 效果如下（图中的照片是一张背景图）： 1.1.2. QComboBox参考链接：Qt Style Sheet实践（二）：组合框QComboBox的定制 1.1.3. QEditLine一般用 QEditLine 控件实现搜索框。 12345678910111213141516171819query_button = new QPushButton();query_button-&gt;setFixedWidth(50);query_button-&gt;setCursor(Qt::PointingHandCursor);query_button-&gt;setToolTip(tr("搜索"));// query_button-&gt;setFlat(true); // 实现按钮透明query_button-&gt;setStyleSheet("QPushButton&#123;background:url(:/button/button_search) center no-repeat; border: none;&#125;");query_edit = new QLineEdit();query_edit-&gt;setFixedWidth(530);query_edit-&gt;setPlaceholderText(tr("请输入要搜索的id"));query_edit-&gt;setStyleSheet("background-color: rgb(29,33,41); color: rgb(255,255,255); height: 35px; border: 1px solid rgb(66,169,235); border-radius: 6px;");QMargins margins = query_edit-&gt;textMargins(); // 设置文本与搜索框的边距，避免太靠近query_edit-&gt;setTextMargins(margins.left(), margins.top(), query_button-&gt;width(), margins.bottom());QHBoxLayout *query_edit_layout = new QHBoxLayout(); // 设置 query_edit 的布局query_edit_layout-&gt;addStretch();query_edit_layout-&gt;addWidget(query_button);query_edit_layout-&gt;setSpacing(0);query_edit_layout-&gt;setContentsMargins(0, 0, 5, 0);query_edit-&gt;setTextMargins(8, 0, 0, 0);query_edit-&gt;setLayout(query_edit_layout); 效果如下： 其他的样式设计可参考：Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全 1.1.4. QCheckbox 参数 效果说明 “QCheckBox::indicator {width: 20px; height: 20px;}” 设置勾选框的大小 “QCheckBox::indicator:unchecked {image: url(:/checkbox/unchecked);}” 设置勾选框未勾选时的效果 “QCheckBox::indicator:unchecked:hover {image: url(:/checkbox/unchecked_hover);}” 设置勾选框未勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:unchecked:pressed {image: url(:/checkbox/unchecked_press);}” 设置勾选框未勾选时鼠标点击状态下的效果 “QCheckBox::indicator:checked {image: url(:/checkbox/checked);}” 设置勾选框勾选时的效果 “QCheckBox::indicator:checked:hover {image: url(:/checkbox/checked_hover);}” 设置勾选框勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:checked:pressed {image: url(:/checkbox/checked_press);}” 设置勾选框勾选时鼠标点击状态下的效果 1.1.5. QPushButtonQPushButton 的独特的样式如下： 参数 效果说明 “QPushButton{background-color: rgb(66,169,235);}” 设置正常状态下 QPushButton 的背景色 “QPushButton:hover{background-color: rgb(60,195,245);}” 设置鼠标悬浮状态下 QPushButton 的背景色 “QPushButton:pressed{background-color: rgb(9,140,188);}” 设置鼠标点击状态下 QPushButton 的背景色 以上设置背景色的方法还可以改为设置图片，方法为：将 “background-color: rgb(66,169,235)” 改为 “border-image: url(:/pushbutton_normal.png)” 1.1.6. QScrollBar设置水平滚动条： 12345table_widget-&gt;horizontalScrollBar()-&gt;setStyleSheet("QScrollBar:horizontal&#123;background:rgb(32,36,45); padding-top:1px; padding-bottom:1px; padding-left:20px; padding-right:20px; border:1px solid rgb(38,42,53); height: 16px;&#125;" // 整体设置 "QScrollBar::handle:horizontal&#123;background:rgb(47,53,66); border-radius: 6px; border: 1px solid rgb(32,36,45);&#125;" // 设置滚动条 "QScrollBar::hadnle:horizontal:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:horizontal&#123;background:url(:/scrollbar/arrow_right) center on-repeat;&#125;" // 设置右箭头 "QScrollBar::sub-line:horizontal&#123;background:url(:/scrollbar/arrow_left) center no-repeat;&#125;"); // 设置左箭头 设置垂直滚动条： 12345table_widget-&gt;verticalScrollBar()-&gt;setStyleSheet("QScrollBar:vertical&#123;background:rgb(32,36,45); padding-top:20px; padding-bottom:20px; padding-left:1px; padding-right:1px; border:1px solid rgb(38,42,53); width: 16px;&#125;" // 整体设置 "QScrollBar::handle:vertical&#123;background:rgb(47,53,66); border-radius: 6px; border: none;&#125;" // 设置滚动条 "QScrollBar::hadnle:vertical:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:vertical&#123;background:url(:/scrollbar/arrow_down) center on-repeat;&#125;" // 设置下箭头 "QScrollBar::sub-line:vertical&#123;background:url(:/scrollbar/arrow_up) center no-repeat;&#125;"); // 设置上箭头 QScrollBar 的一些样式属性说明： 1.1.7. QTableWidget设置表格样式： 123table_widget-&gt;setStyleSheet("selection-background-color: rgb(0, 120, 215)"); // 设置选中时的背景色table_widget-&gt;setStyleSheet("QWidget&#123;background-color: rgb(32,37,45)&#125;" // 设置普通状态下的背景色 "QTableWidget::item&#123;border-top: 1px solid rgb(38, 42, 53); border-bottom: 1px solid rgb(38, 42, 53)&#125;"); // 设置表格单元格 1.2. 参考资料 Qt Style Sheets Reference Qt Style Sheets Examples The Style Sheet Syntax Qt控件美化 Qt Style Sheet实践（一）：按钮及关联菜单 Qt Style Sheet实践（二）：组合框QComboBox的定制 Qt Style Sheet实践（三）：QCheckBox和QRadioButton Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>界面样式</tag>
      </tags>
  </entry>
</search>