<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试问答汇总]]></title>
    <url>%2F2017%2F08%2F30%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[操作系统 请问死锁的条件是什么？以及如何处理死锁问题？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[货箱装载问题]]></title>
    <url>%2F2017%2F08%2F27%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%B4%A7%E7%AE%B1%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 装箱问题1 1.1. 问题描述 1.2. 问题求解 2. 装箱问题2 2.1. 问题描述 2.2. 问题分析 2.3. 问题求解 2.3.1. 装载问题的回溯算法 2.3.2. 装载问题的迭代算法 1. 装箱问题11.1. 问题描述在装箱问题中，箱子的数量不限，每个箱子的容量为 binCapacity，待装箱的物品有 n 个，物品 i 需要占用的箱子容量为 $objectSize[i],0{\leq}objectSize[i]{\leq}binCapacity$。所谓 可行装载（feasible packing），是指所有物品都装入箱子而不溢出。所谓 最优装载（optimal packing） 是指使用箱子最少的可行装载。 1.2. 问题求解近似算法：箱子装载问题和机器调度问题一样，是 NP-复杂问题，因此常用近似算法求解。求解所得的箱子树不是最少，但接近最少，有5中流行的近似算法： 最先适配法（First Fit, FF）：物品按 $1,2,3…,n$ 的顺序装箱。假设箱子从左到右排列，每一物品 i 放入可装载它的最左面的箱子。 最优适配法（Best Fit, BF）：令 $bin[j].unusedCapacity$ 为箱子 j 的可用容量。初始时，所有箱子的可用容量为 $binCapacity$。物品 i 放入可用容量 $unusedCapacity$ 最小但不小于 $object[i]$ 的箱子（此方法更能充分的利用空间）。 最先适配递减法（First Fit Decreasing, FFD）：此方法与 FF 类似，区别在于，所有物品首先按所需容量的递减次序排列，即对于 $1{\leq}i&lt;n$，有 $objectSize[i]{\geq}objectSize[i+1]$。 最优适配递减法（Best Fit Decreasing，BFD）：此方法与 BF 类似，区别在于，所有物品首先按所需容量的递减的次序排列，即对于 $1{\leq}i&lt;n$，有 $objectSize[i]{\geq}objectSize[i+1]$。 相邻适配法：为装载一件物品，首先在非空的箱子中循环搜索能够装载该物品的箱子，如果找不到这样的箱子，就启用一个空箱子。 定理：设 $I$ 为装在问题的任一实例，$b(I)$ 为最优装载所用的箱子数，FF 和 BF 所用的箱子数不会超过 $(17/10)b(I)+2$，而 FFD 和 BFD 所用的箱子数不会超过 $(11/9)b(I)+4$。 实例：假设有 4 件物品，所需容量分别为 $objectSize[1:4]=[3, 5, 2, 4]$，把他们放入容量均为 7 的箱子。 使用 FF 法：共用了三个箱子：物品 1 和 3 放入箱子 1；物品 2 放入箱子 2；物品 4 放入箱子 3. 使用 BF 法：只用了两个箱子：物品 1 和 4 放入箱子 1；物品 2 和 3 放入箱子 2. 如果使用 FFD 和 BFD 方法：物品按 2,4,1,3 排序，最后结果一样；物品 2 和 3 放入箱子 1，物品 1 和 4 放入箱子 2. 用最先适配法求解装箱问题：可用 赢者树 实现。具体参考《数据结构、算法与应用 C++语言描述》（第二版）书籍的第 13 章（竞赛树）第 13.5 节。另一种用 二叉搜索树 实现的参考该书的第 14 章（搜索树）第 14.6.2 节。 2. 装箱问题22.1. 问题描述有两艘船，$n$个货箱。第一艘船的载重重量是$c_1$，第二艘船的载重重量是$c_2$。$w_i$是货箱$i$的重量且${\sum}_{i=1}^{n}{w_i}{\leq}{c_1+c_2}$。希望确定是否有一种方法可以把$n$个货箱全部装上船。如果有，找出这种方法。 扩展：当${\sum}_{i=1}^{n}{w_i}={c_1+c_2}$时，两艘船的装载问题等价于 子集之和（sum-of-subset） 问题，即有$n$个数字，要求找到一个子集（如果存在的话），使它的和为$c_1$。当$c_1=c_2$且${\sum}_{i=1}^{n}{w_i}={2c_1}$时，两艘船的装载问题等价于 分割问题（partition problem），即有$n$个数字$a_i(1{\leq}i{\leq}n)$，要求找到一个子集（如果存在的话），使得子集之和为$({\sum}_{i=1}^{n}{a_i}){/2}$。 2.2. 问题分析只要有一种可行的方案，就可以验证以下的装船策略行之有效： 尽可能将第一艘船装载到它的装载极限； 将剩余货箱装到第二艘船。 为了尽可能地将第一艘船装满，需要选择一个货箱的子集，它们的总重量尽可能接近于$c_1$，这个选择可通过0/1背包问题解决： $${\max}{\sum}_{i=1}^{n}{w_i x_i}$$ 限制条件是 $${\sum}_{i=1}^{n}{w_i x_i}{\leq}{c_i}{\;\;\;}{x_i}{\in}{0,1},1{\leq}i{\leq}n$$ 可以使用动态规划法确定第一艘船的最佳装载。这里使用回溯法设计一个复杂度为$O(2^n)$的算法。 构建解空间树表示，以3个货箱的装箱问题为例，树形表示如下：1234567 A / \ B C / \ / \ D E F G / \ / \ / \ / \H I J K L M N O 每个非叶子节点左子树表示1，右子树表示0。从$A$到$I$表示一种装箱策略，为$(1,1,0)$，即将第一和第二两个货箱装入第一艘船中。采用深度优先遍历该树即可得到货物装箱的所有可行解以及最优解。 可以看到，有些节点右子树不可能包含比当前最优解更好的解，则不需要移动到这种右子树中去。令$Z$为解空间树的第$i$层的一个节点。以$Z$为根的子树中没有叶节点的重量超过 weightOfCurrentLoading + remainingWeight（这两个变量的含义见代码1.3.1. 装载问题的回溯算法），其中remainingWeight = ${\sum}_{j=i+1}^{n}$weight[j]为剩余货箱的重量（$n$是货箱的数量）。因此，当weightOfCurrentLoading + remainingWeight ${\leq}$ maxWeightSoFar没有必要搜索$Z$的右子树 实现代码为1.3.1. 装载问题的回溯算法。 确定第一艘船的最佳装载后，判断剩余货物的总重量是否不大于第二艘船的载重重量$c_2$，如果是，则找到一个可行装载。 2.3. 问题求解2.3.1. 装载问题的回溯算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 装载问题求解 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/* * 问题描述：有两艘船，n个货箱。第一艘船的载重重量是c1，第二艘船的载重重量是c2。wi是货箱i的重量且 w1+w2+...+wn&lt;=c1+c2。 * 希望确定是否有一种方法可以把n个货箱全部装上船。如果有，找出这种方法。 * 求解分析：只要有一种可行的方案，就可以验证以下装船策略有效：1.尽可能将第一艘船装载到它的载重量极限； * 2.将剩余货箱装载到第二艘船。为了尽可能地将第一艘船装满，需要选择一个货箱子集，它们的总重量尽可能接近于c1。 * 这个选择可以通过01背包问题解决。 * 求解策略：回溯法。 */int numberOfContainers; // 货箱的数量int capacity; // 船的载重量，即c1int weightOfCurrentLoading; // 当前装载的重量int maxWeightSoFar; // 目前为止最大的载重量int remainingWeight; // 剩余货箱的重量vector&lt;int&gt; weight; // 货箱重量vector&lt;int&gt; currentLoading; // 当前装载的策略，元素是0或者1，分别表示不转载和装载vector&lt;int&gt; bestLoadingSoFar; // 目前为止最优的装载策略，元素是0或者1.void rLoad(int currentLevel)&#123; // 从currentLevel处的节点开始搜索 if (currentLevel &gt;= numberOfContainers)&#123; // 到达一个叶节点，存储更优的解 for (int j = 0; j &lt; numberOfContainers; ++j) bestLoadingSoFar[j] = currentLoading[j]; maxWeightSoFar = weightOfCurrentLoading; return; &#125; // 没有到达一个叶节点，检查子树 remainingWeight -= weight[currentLevel]; if (weightOfCurrentLoading + weight[currentLevel] &lt;= capacity)&#123; // 搜索左子树 currentLoading[currentLevel] = 1; weightOfCurrentLoading += weight[currentLevel]; rLoad(currentLevel + 1); weightOfCurrentLoading -= weight[currentLevel]; &#125; // 因为当weightOfCurrentLoading + remainingWeight &lt;= maxWeightSoFar时， // 即使搜索右子树也不会达到比maxWeightSoFar更好的结果，所以没有必要搜索右子树 if (weightOfCurrentLoading + remainingWeight &gt; maxWeightSoFar)&#123; currentLoading[currentLevel] = 0; // 搜索右子树 rLoad(currentLevel + 1); &#125; remainingWeight += weight[currentLevel];&#125;int main(int argc, char** argv)&#123; // 初始化全局变量 int theWeight[] = &#123;5, 10, 15, 20, 25&#125;; numberOfContainers = sizeof(theWeight)/sizeof(int); capacity = 40; weightOfCurrentLoading = 0; maxWeightSoFar = 0; remainingWeight = 0; weight.assign(theWeight, theWeight + numberOfContainers); currentLoading = vector&lt;int&gt;(numberOfContainers); bestLoadingSoFar = vector&lt;int&gt;(numberOfContainers); for (int i = 0; i &lt; numberOfContainers; ++i) remainingWeight += weight[i]; rLoad(0); // 搜索策略树 for (int i = 0; i &lt; numberOfContainers; ++i) // 输出最优装载策略 cout &lt;&lt; bestLoadingSoFar[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 1;&#125; 代码输出结果：11 1 0 0 1 2.3.2. 装载问题的迭代算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * 装载问题求解 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;int maxLoading(vector&lt;int&gt;&amp; weight, int numberOfContainers, int capacity, vector&lt;int&gt;&amp; bestLoading)&#123; int weightOfCurrentLoading = 0; // 当前装载的重量 int maxWeightSoFar = 0; // 目前为止最大的载重量 int remainingWeight = 0; // 剩余货箱的重量 vector&lt;int&gt; currentLoading(numberOfContainers); // 当前装载的策略，元素是0或者1，分别表示不转载和装载 for (int i = 0; i &lt; numberOfContainers; ++i) remainingWeight += weight[i]; // 对树进行搜索 int currentLevel = 0; while (true)&#123; // 尽可能沿左分支移动 while (currentLevel &lt; numberOfContainers &amp;&amp; weightOfCurrentLoading + weight[currentLevel] &lt;= capacity)&#123; // 移到左孩子 remainingWeight -= weight[currentLevel]; weightOfCurrentLoading += weight[currentLevel]; currentLoading[currentLevel] = 1; ++currentLevel; &#125; if (currentLevel &gt;= numberOfContainers)&#123; // 到达叶节点 for (int j = 0; j &lt; numberOfContainers; ++j) bestLoading[j] = currentLoading[j]; maxWeightSoFar = weightOfCurrentLoading; &#125; else &#123; // 移到右孩子 remainingWeight -= weight[currentLevel]; currentLoading[currentLevel] = 0; ++currentLevel; &#125; // 需要时回溯 while (weightOfCurrentLoading + remainingWeight &lt;= maxWeightSoFar)&#123; // 这颗子树没有更好的叶节点，回溯 --currentLevel; while (currentLevel &gt; 0 &amp;&amp; currentLoading[currentLevel] == 0)&#123; // 从一个右孩子回溯 remainingWeight += weight[currentLevel]; --currentLevel; &#125; if (currentLevel == 0) return maxWeightSoFar; // 移到右子树 currentLoading[currentLevel] = 0; weightOfCurrentLoading -= weight[currentLevel]; ++currentLevel; &#125; &#125;&#125;int main(int argc, char** argv)&#123; int theWeight[] = &#123;5, 10, 15, 20, 25&#125;; int numberOfContainers = sizeof(theWeight)/sizeof(int); // 货箱的数量 int capacity = 40; // 船的载重量，即c1 vector&lt;int&gt; weight(theWeight, theWeight + numberOfContainers); // 货箱重量 vector&lt;int&gt; bestLoadingSoFar(numberOfContainers); // 目前为止最优的装载策略，元素是0或者1. maxLoading(weight, numberOfContainers, capacity, bestLoadingSoFar); cout &lt;&lt; bestLoadingSoFar &lt;&lt; endl; return 1;&#125; 代码输出结果：11 1 0 0 1]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链表问题]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 面试经典链表问题汇总 1.1. 在 O(1) 的时间删除链表节点 1.2. 单链表转置 1.3. 求链表倒数第k个节点 1.4. 求链表的中间节点 1.5. 判断单链表是否存在环 1.6. 找到环的入口点 1.7. 编程判断两个链表是否相交 1.8. 链表有环，如何判断相交 1.9. 两链表相交的第一个公共节点 1.10. 参考链接 1. 面试经典链表问题汇总本文所用到的链表节点定义如下：1234struct Node&#123; int data; Node *next;&#125;; 1.1. 在 O(1) 的时间删除链表节点题目描述：给定链表的头指针和一个节点指针，在 O(1) 的时间删除该节点。 分析：本题与《编程之美》上的「从无头单链表中删除节点」类似。主要思想都是「狸猫换太子」，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。 12345678910//O(1)时间删除链表节点，从无头单链表中删除节点void deleteRandomNode(Node *cur)&#123; assert(cur != NULL); assert(cur-&gt;next != NULL); //不能是尾节点 Node* pNext = cur-&gt;next; cur-&gt;data = pNext-&gt;data; cur-&gt;next = pNext-&gt;next; delete pNext;&#125; 1.2. 单链表转置题目描述：输入一个单向链表，输出逆序反转后的链表。 分析：链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。 123456789101112131415161718192021222324252627//单链表的转置,循环方法Node* reverseByLoop(Node *head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node *pre = NULL; Node *next = NULL; while(head != NULL) &#123; next = head-&gt;next; head-&gt;next = pre; pre = head; head = next; &#125; return pre;&#125;//单链表的转置,递归方法Node* reverseByRecursion(Node *head)&#123; //第一个条件是判断异常，第二个条件是结束判断 if(head == NULL || head-&gt;next == NULL) return head; Node *newHead = reverseByRecursion(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return newHead; //返回新链表的头指针&#125; 1.3. 求链表倒数第k个节点题目描述：输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。 分析：设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。 12345678910111213141516171819//倒数第k个节点Node* theKthNode(Node *head,int k)&#123; if(k &lt; 0) return NULL; //异常判断 Node *slow,*fast; slow = fast = head; int i = k; for(;i&gt;0 &amp;&amp; fast!=NULL;i--) &#123; fast = fast-&gt;next; &#125; if(i &gt; 0) return NULL; //考虑k大于链表长度的case while(fast != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 1.4. 求链表的中间节点题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。 分析：此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。 12345678910111213141516//求链表的中间节点Node* theMiddleNode(Node *head)&#123; if(head == NULL) return NULL; Node *slow,*fast; slow = fast = head; //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件 //while(fast &amp;&amp; fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 1.5. 判断单链表是否存在环题目描述：输入一个单向链表，判断链表是否有环？ 分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。 1234567891011121314151617//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到bool hasCircle(Node *head,Node *&amp;circleNode)&#123; Node *slow,*fast; slow = fast = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; circleNode = fast; return true; &#125; &#125; return false;&#125; 1.6. 找到环的入口点题目描述：输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？ 解题思路： 由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。 为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有： p1走的路径： a+b ＝ n；p2走的路径： a+b+kL = 2n； p2 比 p1 多走了k圈环路，总路程是p1的2倍 根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。 显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。 123456789101112131415161718192021222324//找到环的入口点Node* findLoopPort(Node *head)&#123; //如果head为空，或者为单结点，则不存在环 if(head == NULL || head-&gt;next == NULL) return NULL; Node *slow,*fast; slow = fast = head; //先判断是否存在环 while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) break; &#125; if(fast != slow) return NULL; //不存在环 fast = head; //快指针从头开始走，步长变为1 while(fast != slow) //两者相遇即为入口点 &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast;&#125; 1.7. 编程判断两个链表是否相交题目描述：给出两个单向链表的头指针，比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。 解题思路：考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。 123456789101112131415//判断两个链表是否相交bool isIntersect(Node *h1,Node *h2)&#123; if(h1 == NULL || h2 == NULL) return false; //异常判断 while(h1-&gt;next != NULL) &#123; h1 = h1-&gt;next; &#125; while(h2-&gt;next != NULL) &#123; h2 = h2-&gt;next; &#125; if(h1 == h2) return true; //尾节点是否相同 else return false;&#125; 1.8. 链表有环，如何判断相交题目描述：上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么? 分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。 1234567891011121314151617//判断两个带环链表是否相交bool isIntersectWithLoop(Node *h1,Node *h2)&#123; Node *circleNode1,*circleNode2; if(!hasCircle(h1,circleNode1)) //判断链表带不带环，并保存环内节点 return false; //不带环，异常退出 if(!hasCircle(h2,circleNode2)) return false; Node *temp = circleNode2-&gt;next; while(temp != circleNode2) &#123; if(temp == circleNode1) return true; temp = temp-&gt;next; &#125; return false;&#125; 1.9. 两链表相交的第一个公共节点题目描述：如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？ 分析：采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。 12345678910111213141516171819202122232425//求两链表相交的第一个公共节点Node* findIntersectNode(Node *h1,Node *h2)&#123; int len1 = listLength(h1); //求链表长度 int len2 = listLength(h2); //对齐两个链表 if(len1 &gt; len2) &#123; for(int i=0;i&lt;len1-len2;i++) h1=h1-&gt;next; &#125; else &#123; for(int i=0;i&lt;len2-len1;i++) h2=h2-&gt;next; &#125; while(h1 != NULL) &#123; if(h1 == h2) return h1; h1 = h1-&gt;next; h2 = h2-&gt;next; &#125; return NULL;&#125; 1.10. 参考链接 面试精选：链表问题集锦 面试算法之链表操作集锦]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的简单操作]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 二叉树操作 1.1. 二叉树遍历： 1.2. 二叉树的高 1. 二叉树操作1.1. 二叉树遍历：问题描述：使用前序遍历、中序遍历、后序遍历和层次遍历输出二叉树的节点 求解策略：根据定义，前三种遍历采用递归实现，而层次遍历采用队列（不是栈）来存储将要访问的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* visit 函数 */template&lt;typename T&gt;void visit(binaryTreeNode&lt;T&gt;* x)&#123; cout &lt;&lt; x-&gt;element &lt;&lt; ' ';&#125;/* 前序遍历 */template&lt;typename T&gt;void preOrder(binaryTreeNode&lt;T&gt;* t)&#123; if (t != NULL)&#123; visit(t); preOrder(t-&gt;leftChild); // 前序遍历左子树 preOrder(t-&gt;rightChild); // 前序遍历右子树 &#125;&#125;/* 中序遍历 */template&lt;typename T&gt;void inOrder(binaryTreeNode&lt;T&gt;* t)&#123; if (t != NULL)&#123; inOrder(t-&gt;leftChild); // 中序遍历左子树 visit(t); inOrder(t-&gt;rightChild); // 中序遍历右子树 &#125;&#125;/* 后序遍历 */template&lt;typename T&gt;void postOrder(binaryTreeNode&lt;T&gt;* t)&#123; if (t != NULL)&#123; postOrder(t-&gt;leftChild); // 后序遍历左子树 postOrder(t-&gt;rightChild); // 后序遍历右子树 visit(t); &#125;&#125;/* 层次遍历 */template &lt;typename T&gt;void levelOrder(binaryTreeNode&lt;T&gt;* t)&#123; queue&lt;binaryTreeNode&lt;T&gt;*&gt; q; binaryTreeNode&lt;E&gt; *t = root; while (t != NULL)&#123; visit(t); // 将 s 的孩子插入队列 if (t-&gt;leftChild != NULL) q.push(t-&gt;leftChild); if (t-&gt;rightChild != NULL) q.push(t-&gt;rightChild); // get next node to visit if (q.empty()) return; t = q.front(); q.pop(); &#125;&#125; 时间复杂度：这四种方法的时间和空间复杂度均为 O(n)。 1.2. 二叉树的高问题描述：给一颗二叉树，求它的高度。 求解策略：利用递归。先取得左子树高度，然后获取右子树高度，最后把左右子树高度的最大者加上 1，即得到树的高度。 12345678910/* 确定二叉树的高度 */template&lt;typename T&gt;int height(binaryTreeNode&lt;T&gt;* t)&#123; if (t == NULL) return 0; // 空树 int hl = height(t-&gt;leftChild); // 左树高 int hr = height(t-&gt;rightChild); // 右树高 int max = (hl&gt;hr) ? hl : hr; return ++max;&#125;]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的简单应用]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E9%98%9F%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 队列的简单应用汇总 1.1. 图元识别 1.2. 工厂仿真 1. 队列的简单应用汇总1.1. 图元识别问题描述：数字化图像是一个 m*m 的像素矩阵。在单色图像中，每个像素的值要么为0，要么为1。值为1的像素表示图元上的一个点，称其为图元像素。两个像素是相邻的，是指它们左右相邻或上下相邻。像个相邻的图元像素是同一个图元的像素。图元识别的目的就是给图元像素做标记，使两个像素标记相同，当且仅当它们是同一个图元的像素。 123456 | 0 1 0 1 1 0 2 0 3 3 | 0 1 1 0 1 0 2 2 0 30 1 1 0 2 2 | 0 0 1 0 1 0 0 2 0 31 0 1 3 0 2 | 1 0 0 0 1 4 0 0 0 31 1 0 3 3 0 | 1 1 0 1 1 4 4 0 3 3a1) 3*3的图像 a2)已标记的图元 | b1) 5*5的图像 b2) 已标记的图元 在上图中，图元像素都做了标记，两个像素标记相同，当且仅当它们属于同一个图元，用数字 2，3，4… 作为图元标记。 求解策略：通过扫描像素来识别图元，扫描的方式是逐行扫描，每一行逐行扫描。当扫描到一个未标记的图元像素时，给它一个图元标记。然后把这个图元像素作为一个新图元的种子，通过识别和标记所有与该种子相邻的图元像素，来寻找新图元剩余的像素。这个过程一直持续到没有新的、未标记的、相邻的图元像素为止。 标记图元像素的程序用到很多技巧：用 0 值像素在图像四周建立“围墙”；用数组 offset 来寻找与给定像素相邻的像素。借助一个队列（也可以是个栈），来存储本身已经标记，而其相邻位置尚未标记的方格。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;/* 图元识别 */typedef struct position&#123; int row; int col;&#125;position;vector&lt;vector&lt;int&gt; &gt; pixel; // 数字化图像，方形int size; // 数字化图像尺寸void labelComponents()&#123; // 给图元编号 // 初始化数组 offset position offset[4]; offset[0].row = 0; offset[0].col = 1; // 右 offset[1].row = 1; offset[1].col = 0; // 下 offset[2].row = 0, offset[2].col = -1; // 左 offset[3].row = -1; offset[3].col = 0; // 上 // 初始化 0 值像素围墙 for (int i = 0; i &lt;= size + 1; ++i)&#123; pixel[0][i] = pixel[size + 1][i] = 0; // 底部和顶部 pixel[i][0] = pixel[i][size + 1] = 0; // 左和右 &#125; int numOfNbrs = 4; // 一个像素的相邻位置数 // 扫描所有像素，标记图元 queue&lt;position&gt; q; position here, nbr; int id = 1; // 图元 id for (int r = 1; r &lt;= size; ++r)&#123; // 图像的行 r for (int c = 1; c &lt;= size; ++c)&#123; // 图像的列 c if (pixel[r][c] == 1)&#123; // 新图源 pixel[r][c] = ++id; // 取下一个图元 here.row = r; here.col = c; while (true)&#123; // 寻找其他图元 for (int i = 0; i &lt; numOfNbrs; ++i)&#123; // 检查所有相邻位置 nbr.row = here.row + offset[i].row; nbr.col = here.col + offset[i].col; if (pixel[nbr.row][nbr.col] == 1)&#123; // 当前图元的一部分 pixel[nbr.row][nbr.col] = id; q.push(nbr); &#125; &#125; // 图元中任意未考察的像素 if (q.empty()) break; here = q.front(); // 一个图像的图元 q.pop(); &#125; &#125; &#125; &#125;&#125;/* main 函数 */int main(int argc, char **argv)&#123; /* 图元问题 */ size = 3; int temp[5][5] = &#123; &#123;0, 0, 0, 0, 0&#125;, &#123;0, 0, 1, 1, 0&#125;, &#123;0, 1, 0, 1, 0&#125;, &#123;0, 1, 1, 0, 0&#125;, &#123;0, 0, 0, 0, 0&#125;&#125;; pixel.resize(5); for (int i = 0; i &lt; 5; ++i)&#123; pixel[i].assign(&amp;temp[i][0], &amp;temp[i][5]); &#125; labelComponents(); for (int i = 1; i &lt;= size; ++i)&#123; for (int j = 1; j &lt;= size; ++j)&#123; cout &lt;&lt; pixel[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 1;&#125; 时间复杂度：函数 labelComponents 总的时间复杂度为 O(m^2) 1.2. 工厂仿真略]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆的简单应用]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%A0%86%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 堆的简单应用 1.1. 大根堆的操作 1.2. 机器调度 1. 堆的简单应用1.1. 大根堆的操作问题描述： 实现判断大根堆、大根堆的初始化、大根堆的插入、大根堆的删除、堆排序的操作。 求解策略： 大根堆判断：这里可以采用非递归和递归两种方式进行判断。 非递归：采用层次遍历，依次判断每个节点和其左右孩子（如果有的话）的大小关系，如果该节点的值小于其其中一个孩子节点的值，则不是大根堆；否则，继续判断下一个节点，直到所有节点判断完成为止。可用一个队列存储一些节点的编号，这些节点满足：该节点还未进行判断，但其父节点已经判断过满足大根堆的定义。这样每次从队列中取出一个节点进行判断，直到队列为空为止。（代码中函数 IsMaxHeap() 就是采用的非递归实现的） 递归：对每一个节点，每次只判断该节点和其左右孩子（如果有的话）的大小关系，对其孩子节点，只判断其孩子节点和其孩子的左右孩子的大小关系，依此类推，直到所有节点判断完毕为止。（代码中函数 IsMaxHeap2() 就是采用递归实现的） 大根堆的初始化：对每一个非叶子节点，判断其与左右孩子中较大者的关系，如果该节点的值大于其左右孩子中的较大者，则不进行任何操作，否则，交换该节点与孩子中较大者的值，即是该节点的下沉过程。采用此方法，从最后一个非叶子节点开始调整，直到调整到根节点为止。 大根堆的插入：将新元素插入到数组最后，然后判断新元素与其父节点的关系，如果大于其父节点的值，则交换其与父节点的值，继续此操作，直到其小于其父节点的值，则插入元素完成。该过程即是新元素上浮的过程。 堆排序：每次将根元素与最后一个未排序的元素交换，然后从根结点调整，使未排序的元素成为一个最大堆。依此类推，直到所有元素都排序完成，产生一个从小到大的序列，排序过后的序列就不是一个堆了。此方法时间复杂度为 $O(nlogn)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* 堆的应用：堆排序、机器调度、霍夫曼编码 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i)&#123; out &lt;&lt; vec[i] &lt;&lt; ' '; &#125; return out;&#125;/* 大根堆堆的操作：判断是不是大根堆、堆的调整、堆的插入、堆的删除、堆排序，堆用数组表示。 *//* 判断是不是大根堆 */template&lt;typename T&gt;bool IsMaxHeap(vector&lt;T&gt;&amp; heap)&#123; // 根据定义，判断每一个节点与其孩子的关系。非递归，采用层次遍历。 if (heap.size() &lt;= 1) return true; queue&lt;int&gt; q; // 存储将要判断的节点的编号 int size = heap.size(); int root = 0; while (root &lt; size)&#123; if (2*root+1 &lt; size)&#123; if (heap[root] &gt;= heap[2*root+1]) q.push(2*root+1); // 将 root 的左孩子存在队列中 else return false; &#125; if (2*root+2 &lt; size)&#123; if (heap[root] &gt;= heap[2*root+2]) q.push(2*root+2); // 将 root 的右孩子存在队列中 else return false; &#125; if (q.empty()) break; root = q.front(); q.pop(); &#125; return true;&#125;template&lt;typename T&gt;bool IsMaxHeap2(vector&lt;T&gt;&amp; heap, int root)&#123; // 递归实现，每次只判断节点和其左右孩子的关系 if (heap.size() &lt;= 1) return true; if (root &gt;= heap.size())&#123; cout &lt;&lt; root &lt;&lt; " should not be &gt;= " &lt;&lt; heap.size() &lt;&lt; endl; return false; &#125; int size = heap.size(); if (2*root+1 &lt; size)&#123; if (heap[root] &lt; heap[2*root+1]) return false; else IsMaxHeap2(heap, 2*root+1); &#125; if (2*root+2 &lt; size)&#123; if (heap[root] &lt; heap[2*root+2]) return false; else IsMaxHeap2(heap, 2*root+2); &#125; return true;&#125;/* 大根堆的调整 */template&lt;typename T&gt;void MaxHeapAdjust(vector&lt;T&gt;&amp; heap, int root, int length)&#123; // 调整以节点 root 为根的子树，length 为调整到的最大编号 while (2*root + 1 &lt; length)&#123; int child = 2*root + 1; if (2*root + 2 &lt; length &amp;&amp; heap[2*root+2] &gt; heap[2*root+1]) child = 2*root + 2; // 取以 root 节点为根的左右孩子值较大的那个 if (heap[child] &gt; heap[root]) swap(heap[child], heap[root]); // 如果孩子较大的那个比根还大，则交换它们 root = child; // 根元素的下沉过程 &#125;&#125;/* 大根堆插入 */template&lt;typename T&gt;void MaxHeapPush(vector&lt;T&gt;&amp; heap, const T&amp; element)&#123; // 注意这里如果插入元素时没有剩余的空间，vector 会自动扩容 if (!IsMaxHeap2(heap, 0))&#123; // 判断是不是堆，不是则返回 cout &lt;&lt; "error! not a heap." &lt;&lt; endl; return; &#125; heap.push_back(element); int size = heap.size(); int currentNode = size - 1; while (currentNode != 0 &amp;&amp; heap[currentNode] &gt; heap[(currentNode-1)/2])&#123; // 插入的节点元素上浮 swap(heap[currentNode], heap[(currentNode-1)/2]); currentNode = (currentNode-1)/2; &#125;&#125;/* 大根堆删除 */template&lt;typename T&gt;void MaxHeapPop(vector&lt;T&gt;&amp; heap)&#123; // 删除根元素 if (heap.size() == 0) // 没有元素，直接返回 return; if (!IsMaxHeap2(heap, 0))&#123; // 判断是不是堆，不是则返回 cout &lt;&lt; "error! not a heap." &lt;&lt; endl; return; &#125; swap(heap[0], heap[heap.size()-1]); // 交换第一个元素和最后一个元素 heap.pop_back(); // 删除最后一个元素 MaxHeapAdjust(heap, 0, heap.size()); // 重新调整，使其成为大根堆&#125;/* 大根堆排序 */template&lt;typename T&gt;void MaxHeapSort(vector&lt;T&gt;&amp; heap)&#123; // 从小到大排序 for (int i = heap.size()/2-1; i &gt;= 0; --i) // 使输入成为一个堆 MaxHeapAdjust(heap, i, heap.size()); for (int i = heap.size() - 1; i &gt; 0; --i)&#123; swap(heap[0], heap[i]); // 将第0个元素与最后一个未排序的元素交换 MaxHeapAdjust(heap, 0, i); // 重新调整以根结点的堆，调整的长度为未排序的长度 &#125;&#125;/* main 函数 */int main(int argc, char** argv)&#123; int arr[] = &#123;6, 9, 3, 8, 2, 4, 7, 1, 5&#125;; vector&lt;int&gt; heap(arr, arr + sizeof(arr)/sizeof(int)); cout &lt;&lt; "initial matrix: " &lt;&lt; heap &lt;&lt; endl; cout &lt;&lt; "is heap: [method 1: " &lt;&lt; IsMaxHeap(heap) &lt;&lt; "]\t [method 2: " &lt;&lt; IsMaxHeap2(heap, 0) &lt;&lt; "]" &lt;&lt; endl; cout &lt;&lt; "----------------------------------------" &lt;&lt; endl; for (int i = heap.size()/2-1; i &gt;= 0; --i) // 创建堆 MaxHeapAdjust(heap, i, heap.size()); cout &lt;&lt; "initial heap: " &lt;&lt; heap &lt;&lt; endl; cout &lt;&lt; "is heap: [method 1: " &lt;&lt; IsMaxHeap(heap) &lt;&lt; "]\t [method 2: " &lt;&lt; IsMaxHeap2(heap, 0) &lt;&lt; "]" &lt;&lt; endl; cout &lt;&lt; "----------------------------------------" &lt;&lt; endl; MaxHeapPush(heap, 0); // 插入元素 cout &lt;&lt; "heap push: " &lt;&lt; heap &lt;&lt; endl; cout &lt;&lt; "is heap: [method 1: " &lt;&lt; IsMaxHeap(heap) &lt;&lt; "]\t [method 2: " &lt;&lt; IsMaxHeap2(heap, 0) &lt;&lt; "]" &lt;&lt; endl; cout &lt;&lt; "----------------------------------------" &lt;&lt; endl; MaxHeapPop(heap); // 删除元素 cout &lt;&lt; "heap pop: " &lt;&lt; heap &lt;&lt; endl; cout &lt;&lt; "is heap: [method 1: " &lt;&lt; IsMaxHeap(heap) &lt;&lt; "]\t [method 2: " &lt;&lt; IsMaxHeap2(heap, 0) &lt;&lt; "]" &lt;&lt; endl; cout &lt;&lt; "----------------------------------------" &lt;&lt; endl; MaxHeapSort(heap); // 堆排序，堆排序后就不是一个堆了 cout &lt;&lt; "heap sort: " &lt;&lt; heap &lt;&lt; endl; cout &lt;&lt; "is heap: [method 1: " &lt;&lt; IsMaxHeap(heap) &lt;&lt; "]\t [method 2: " &lt;&lt; IsMaxHeap2(heap, 0) &lt;&lt; "]" &lt;&lt; endl; cout &lt;&lt; "----------------------------------------" &lt;&lt; endl; return 1;&#125; 程序执行结果为：1234567891011121314initial matrix: 6 9 3 8 2 4 7 1 5is heap: [method 1: 0] [method 2: 0]----------------------------------------initial heap: 9 8 7 6 2 4 3 1 5is heap: [method 1: 1] [method 2: 1]----------------------------------------heap push: 9 8 7 6 2 4 3 1 5 0is heap: [method 1: 1] [method 2: 1]----------------------------------------heap pop: 8 6 7 5 2 4 3 1 0is heap: [method 1: 1] [method 2: 1]----------------------------------------heap sort: 0 1 2 3 4 5 6 7 8is heap: [method 1: 0] [method 2: 0] 1.2. 机器调度问题描述： 一个工厂具有 $m$ 台一模一样的机器。我们有 $n$ 个作业要处理。设作业 $i$ 的处理时间为 $t_i$，这个时间包括把作业放入机器和从机器上取下的时间。所谓 调度（schedule） 是指按作业在机器上的运行时间分配作业，使得； 一台机器在同一时间内只能处理一个作业； 一个作业不能同时在两台机器上处理； 一个作业 $i$ 的处理时间是 $t_i$ 个时间单位。 假如每台机器在 0 时刻都是可用的，完成时间（finish time） 或 调度长度（length of a schedule） 是指完成所有作业的时间。在一个非抢先调度中，一项作业 $i$ 在一台机器上处理，从时刻 $s_i$ 开始，到时刻 $s_i+t_i$ 结束。 例如：有 3 台机器要处理 7 个作业，这 7 个作业的处理时间分别为 $(2, 14, 4, 16, 6, 5, 3)$。3 台机器的编号为 $M1,M2,M3$。则最优的调度安排如下（作业编号从 0 开始）：（其完成全部作业所需时间为 17） 机器编号 任务编号 处理时间 $M1$ 3 16 = 16 $M2$ 1,6 14+3 = 17 $M3$ 4,5,2,0 6+5+4+2 = 17 任务就是写一个程序，实现在 $m$ 台机器上执行 $n$ 个作业的最小完成时间的调度。 求解策略： 调度问题是 NP-复杂问题（NP 表示 nondeterministic polynornial） 中的一个。NP-复杂问题及 NP-完全问题是指尚未找到具有多项式时间复杂性算法的问题。NP-完全问题是一类判定问题，也就是说，对这类问题的每一个实例，答案为是或否。NP-复杂问题的优化问题经常用 近似算法（approximation aigorithm） 解决，虽然近似算法不能保证得到最优解，但是能保证得到近似最优解。 在本调度问题中，采用一个简单调度策略，称为 最长处理时间（longest processing time, LPT），它的调度长度是最优调度长度的 $4/3-1/(3m)$。在 $LPT$ 算法中，作业按处理时间的递减顺序排列。当一个作业需要分配时，总是分配给最先变为空闲的机器。 可用堆来建立 $LPT$ 调度方案，时间性能为 $O(nlogn)$。当 $n{\leq}m$ 时，只需要将作业 $i$ 在 $0$ ~ $t_i$ 时间分配给机器 $i$ 来处理。当 $n&gt;m$ 时，可以首先利用堆排序将作业按处理时间递减顺序排列。为了建立 $LPT$ 调度方案，作业按处理时间从大到小顺序进行分配。为了决定将一个作业分配给哪一台机器，必须知道哪台机器最先空闲。为此，维持一个 $m$ 台机器的小根堆。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // 主要使用 make_heap(),push_heap(),pop_heap(),sort_heap() 函数using namespace std;/* 机器调度 *//* 类 jobNode 表示作业 */class jobNode&#123; friend int makeSchedule(vector&lt;jobNode&gt;&amp;, int, int); friend int main(int, char**); public: operator int () const &#123;return time;&#125; private: int id, // job identifier time; // processing time&#125;;/* 类 machineNode 表示机器 */class machineNode&#123; friend int makeSchedule(vector&lt;jobNode&gt;&amp;, int, int); public: machineNode(int theID = 0, int theAvail = 0)&#123; id = theID; avail = theAvail; &#125; operator int () const &#123;return avail;&#125; private: int id, // machine identifier avail; // when it becones free&#125;;int makeSchedule(vector&lt;jobNode&gt;&amp; vec, int n, int m)&#123; // n 表示任务数量，m 表示机器数量 make_heap(vec.begin(), vec.end(), greater&lt;jobNode&gt;()); sort_heap(vec.begin(), vec.end(), greater&lt;jobNode&gt;()); // 从大到小排序 if (n &lt;= m)&#123; cout &lt;&lt; "Schedule each job on a different machine." &lt;&lt; endl; return vec.front().time; &#125; // 初始化 m 台机器，建立小根堆 vector&lt;machineNode&gt; machineHeap(m); for (int i = 0; i &lt; m; ++i) machineHeap[i] = machineNode(i, 0); make_heap(machineHeap.begin(), machineHeap.end(), greater&lt;machineNode&gt;()); // 建立小根堆 // 生成调度计划 for (int i = 0; i &lt; n; ++i)&#123; // 把作业 i 安排在第一台空闲的机器 pop_heap(machineHeap.begin(), machineHeap.end(), greater&lt;machineNode&gt;()); machineNode x = machineHeap.back(); machineHeap.pop_back(); cout &lt;&lt; "Schedule job " &lt;&lt; vec[i].id &lt;&lt; " on machine " &lt;&lt; x.id &lt;&lt; " from " &lt;&lt; x.avail &lt;&lt; " to " &lt;&lt; (x.avail + vec[i].time) &lt;&lt; endl; x.avail += vec[i].time; machineHeap.push_back(x); push_heap(machineHeap.begin(), machineHeap.end(), greater&lt;machineNode&gt;()); &#125; make_heap(machineHeap.begin(), machineHeap.end(), less&lt;machineNode&gt;()); // 重建大根堆 return machineHeap.front().avail;&#125;/* main 函数 */int main(int argc, char** argv)&#123; /* 机器调度 */ int arrJob[] = &#123;2, 14, 4, 16, 6, 5, 3&#125;; vector&lt;jobNode&gt; vecJob(7); for (int i = 0; i &lt; 7; ++i)&#123; vecJob[i].id = i; vecJob[i].time = arrJob[i]; &#125; cout &lt;&lt; "min finish time = " &lt;&lt; makeSchedule(vecJob, 7, 3) &lt;&lt; endl; return 1;&#125; 程序执行结果为：12345678Schedule job 3 on machine 2 from 0 to 16Schedule job 1 on machine 1 from 0 to 14Schedule job 4 on machine 0 from 0 to 6Schedule job 5 on machine 0 from 6 to 11Schedule job 2 on machine 0 from 11 to 15Schedule job 6 on machine 1 from 14 to 17Schedule job 0 on machine 0 from 15 to 17min finish time = 17 时间复杂度：该方法时间复杂度为 $O(nlogn)$。]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配算法]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 问题描述 2. 求解策略 2.1. 暴力求解 2.2. KMP算法 1. 问题描述如何在字符串数据中，检测和提取以字符串形式给出的某一局部特征，这类操作都属于串模式匹配（string pattern matching）范畴，简称串匹配。一般的，即对基于同一字符表的任何主串$T(|T|=n)$和模式串$P(|P|=m)$：判定$T$中是否存在某一子串与$P$相同，若存在（匹配），则报告该子串在$T$中的起始位置。 一般串的长度都很大，但相对而言$n$更大，即满足$2&lt;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试问题杂谈]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%88%E6%9D%82%E8%B0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[下表总结了各种字典结构的渐进时间性能，其中的函数都是 O() 的最坏情况 方法 查找 插入 删除 有序数组 O(logn) O(n) O(n) 有序链表 O(n) O(n) O(n) 跳表 O(n) O(n) O(n) 哈希表 O(n) O(n) O(n) 二叉搜索树 O(n) O(n) O(n) AVL 树 O(logn) O(logn) O(logn) 红黑树 O(logn) O(logn) O(logn) 分裂树 O(n) O(n) O(n) B 树 O(logn) O(logn) O(logn) 平均情况 方法 查找 插入 删除 有序数组 O(logn) O(n) O(n) 有序链表 O(n) O(n) O(n) 跳表 O(logn) O(logn) O(logn) 哈希表 O(1) O(1) O(1) 二叉搜索树 O(logn) O(logn) O(logn) AVL 树 O(logn) O(logn) O(logn) 红黑树 O(logn) O(logn) O(logn) 分裂树 O(logn) O(logn) O(logn) B 树 O(logn) O(logn) O(logn) 注：STL 类 map 和 multimap 使用的是 红黑树结构，以保证查找、插入和删除操作具有对数级的时间性能。 在实际应用中，当要实施的操作都是按关键字进行查找、插入和删除时，认为散列技术在性能方面超过了平衡搜索树，因此，优先选择散列技术。如果是按关键字实施字典操作，而且操作时间不能超过指定的范围，这时提倡使用平衡搜索树。对于那些按名次实施的查找和删除操作，还有那些不按精确的关键字匹配所进行的字典操作（例如寻找关键字大于 k 的最小元素），建议使用平衡搜索树。 AVL 树和红黑树都使用“旋转”来保持平衡。AVL 树对每个插入操作最多需要一次旋转，对每个删除操作最多需要 O(logn) 次旋转。而红黑树对每个插入和删除操作，都只需要一次旋转。 为什么STL使用红黑树作为平衡树的实现？答：（以下答案引用知乎：https://www.zhihu.com/question/20545708/answer/58717264，侵删） 至于, 为什么不用 AVL 树作为底层实现, 那是因为 AVL 树是高度平衡的树, 而每一次对树的修改, 都要 rebalance, 这里的开销会比红黑树大. 红黑树插入只要两次旋转, 删除至多三次旋转. 但不可否认的是, AVL 树搜索的效率是非常稳定的. 选取红黑树, 我认为是一种折中的方案. 黑体字是不正确的，对AVL插一个node或者删一个node，显然不需要每次都做rotation来维持balance。且AVL插入最多也只需要2次旋转。下面是我的回答： 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。 map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排列组合问题]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 排列组合问题 1.1. 全排列 1.1.1. 全排列 1.1.2. 去重全排列 1.2. 全组合 1. 排列组合问题1.1. 全排列全排列就是有 $n$ 个不同的元素，求所有元素的所有排列。比如 $a,\;b,\;c$ 的所有排列为 ${abc},\;{acb},\;{bac},\;{bca},\;{cab},\;{cba}$。$n$ 个元素的排列个数是 $n!$。 1.1.1. 全排列举例：$a,\;b,\;c$ 的全排列为 ${abc},\;{acb},\;{bac},\;{bca},\;{cab},\;{cba}$。 思路：取集合中的任意一个元素与第一个数字交换，然后将除第一个元素外的后面所有的元素全排列；依次类推。更广泛的，假设前 $m$ 个元素已经排好，将剩下 $n-m$ 个元素全排，就得到了在前 $m$ 个元素已经排好的情况下的全排。用递归实现。 123456789101112131415template&lt;typename T&gt;void permutatons(vector&lt;T&gt; &amp;vec, int k, int m)&#123; if(k == m)&#123; // 递归基础部分 for(int i = 0; i &lt; vec.size(); ++i)&#123; cout &lt;&lt; vec[i]; &#125; cout &lt;&lt; endl; &#125;else&#123; for(int i = k; i &lt;= m; ++i)&#123; swap(vec[k], vec[i]); permutatons(vec, k + 1, m); swap(vec[k], vec[i]); // 交换，还原数组元素 &#125; &#125;&#125; 1.1.2. 去重全排列举例：$a,\;b,\;b$ 的去重全排列为 ${abb},\;{bab},\;{bba}$。 思路：去重全排列就是从要全排的第一个元素分别与它后面每个非重复出现的元素交换。 1234567891011121314151617181920212223242526template&lt;typename T&gt;bool IsSwap(vector&lt;T&gt; &amp;vec, int k, int m)&#123; for(; k &lt; m; ++k)&#123; if(vec[k] == vec[m]) return false; &#125; return true;&#125;template&lt;typename T&gt;void permutatons(vector&lt;T&gt; &amp;vec, int k, int m)&#123; if(k == m)&#123; for(int i = 0; i &lt; vec.size(); ++i)&#123; cout &lt;&lt; vec[i]; &#125; cout &lt;&lt; endl; &#125;else&#123; for(int i = k; i &lt;= m; ++i)&#123; if (IsSwap(vec, k, i))&#123; swap(vec[k], vec[i]); permutatons(vec, k + 1, m); swap(vec[k], vec[i]); &#125; &#125; &#125;&#125; 1.2. 全组合举例：$a,\;b,\;c$ 的全组合为 ${a},\;{b},\;{c},\;{ab},\;{ac},\;{bc},\;{abc}$。 思路：假设有 $n$ 个元素，则共有 $2^n-1$ 种组合。借用位操作，1 表示取该元素，0 表示不取该元素。假设有 $a,\;b,\;c$ 三个元素，则取 $a$ 为 $100$，$ab$ 是 $110$，而 $000$ 没有意义。所以解决方案就是循环 $1$ 至 $2^n-1$，然后输出对应代表的组合即可。 123456789101112131415template&lt;typename T&gt;void combination(vector&lt;T&gt; &amp;vec)&#123; if(vec.size() == 0) return; int len = vec.size(); int n = 1 &lt;&lt; len; for(int i = 1; i &lt; n; ++i)&#123; // 从 1 循环到 2^len-1 for(int j = 0; j &lt; len; ++j)&#123; if(i &amp; (1 &lt;&lt; j))&#123; // 判断第j位是否为1 cout &lt;&lt; vec[j]; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部排序算法汇总]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 常见的内部排序算法汇总-C++描述 1.1. 插入排序（Insertion Sort） 1.2. 希尔排序（Shell Sort） 1.3. 选择排序（Selection Sort） 1.4. 堆排序（Heap Sort） 1.5. 冒泡排序（Bubble Sort） 1.6. 快速排序（Quick Sort） 1.7. 归并排序（Merge Sort） 1.8. 计数排序（Counting Sort） 2. 小结 3. 参考资料 1. 常见的内部排序算法汇总-C++描述排序：将无序的元素序列，通过一定的方法按照关键字顺序排列的过程。排序分为内部排序和外部排序： 内部排序：整个排序过程不需要访问外存便能完成。 外部排序：整个序列的排序过程不可能在内存中完成，需要借助外存才能完成，通常参加排序的数据量很大。 若经过排序，元素之间的相对次序保持不变，则称这种排序算法是稳定的，否则称为不稳定的。 本文是对内部排序算法的总结。 下表给出了常见的排序算法的性能： 排序方法 平均情况 最好情况 最坏情况 辅助空间 稳定性 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(nlogn)$~$O(n^2)$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$~$O(n)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ 稳定 注：本文的实现都是从小到大排序。如果要看直观的动态排序图，参考参考资料中对应的链接。 1.1. 插入排序（Insertion Sort）插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到$O(1)$的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法步骤： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$。 稳定性：稳定 优化：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，称为二分插入排序（代码略，以后补充）。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * 内部排序算法：插入排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 插入排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void insertSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 1; i &lt; n; ++i)&#123; T temp = vec[i]; // 保存第i个元素 int j = i-1; // 第i个元素之前的序列从右向左比较 for (; j &gt;= 0; --j)&#123; if (vec[j] &gt; temp) vec[j+1] = vec[j]; // 如果大于temp，则将该元素后移一位 else break; // 否则不移动，退出 &#125; vec[j+1] = temp; // 将temp赋值给第j+1个元素 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); insertSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.2. 希尔排序（Shell Sort）希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 算法步骤：希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。 例如，假设有这样一组数${\lbrace}13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10{\rbrace}$，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：${\lbrace}10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45{\rbrace}$.这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了）。 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 Donald Shell最初建议步长选择为$n/2$，并且对步长取半直到步长达到1。（本文如下代码既是采用这种方法实现） 时间复杂度：最好的时间复杂度为$O(n)$，而最坏时间复杂度和平均时间复杂度都要根据步长序列的不同而不同。 空间复杂度：$O(n)$ 稳定性：不稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 内部排序算法：希尔排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 希尔排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void shellSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); T temp; for (int step = n &gt;&gt; 1; step &gt; 0; step &gt;&gt;= 1)&#123; for (int i = step; i &lt; n; ++i)&#123; T temp = vec[i]; int j = i - step; for (; j &gt;= 0; j -= step)&#123; if (vec[j] &gt; temp) vec[j+step] = vec[j]; else break; &#125; vec[j+step] = temp; &#125; &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); shellSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.3. 选择排序（Selection Sort）选择排序（Selection sort）是一种简单直观的排序算法。 算法步骤：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n^2)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：不稳定 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 内部排序算法：选择排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 选择排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void selectSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 0; i &lt; n; ++i)&#123; int min = i; for (int j = i + 1; j &lt; n; ++j)&#123; if (vec[j] &lt; vec[min]) min = j; &#125; if (min != i) swap(vec[i], vec[min]); &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); selectSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.4. 堆排序（Heap Sort）堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆节点的访问：通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点$i$的左子节点在位置$2*i+1$; 父节点$i$的右子节点在位置$2*i+2$; 子节点$i$的父节点在位置${\lfloor}(i-1)/2{\rfloor}$; 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点； 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序； 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。 算法步骤： 创建一个最大堆heap[0:n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小1，并从根开始重新调整，使其成为一个堆； 重复步骤2~3，直到堆的尺寸为1。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：不稳定 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * 内部排序算法：堆排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 在vec中调整以root为根的子树 * @param: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') * @param: root: 调整以节点root为根的子树 * @param: n: 调整的的节点索引要小于n，即能调整到的最大编号 */template&lt;typename T&gt;void adjustHeap(vector&lt;T&gt;&amp; vec, int root, int n)&#123; if (root &gt;= n) return; while (2*root+1 &lt; n)&#123; // 左孩子存在 int child = 2*root+1; // 左孩子 if (2*root+2 &lt; n &amp;&amp; vec[2*root+2] &gt; vec[child]) child = 2*root+2; // 取以 root 节点为根的左右孩子值较大的那个 if (vec[child] &gt; vec[root]) // 如果孩子较大的那个比根还大，则交换它们 swap(vec[root], vec[child]); root = child; // 根元素的下沉过程 &#125;&#125;/* * @function: 堆排序，实现从小到大排序，构建最大堆 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void heapSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = (n&gt;&gt;1)-1; i &gt;= 0; --i) // 将待排序序列先调整为一个最大堆 adjustHeap(vec, i, n); for (int i = n-1; i &gt; 0; --i)&#123; swap(vec[0], vec[i]); // 将根元素与最后一个未排序的元素交换 adjustHeap(vec, 0, i); // // 重新调整以根结点的堆，调整的长度为未排序的长度 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); heapSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.5. 冒泡排序（Bubble Sort）冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：稳定。 优化：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。（代码略，以后补充） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 内部排序算法：冒泡排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 冒泡排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void bubbleSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 0; i &lt; n-1; ++i)&#123; bool flag = false; // 标志位，判断一次冒泡中是否有交换 for (int j = 0; j &lt; n-i-1; ++j)&#123; if (vec[j] &gt; vec[j+1])&#123; swap(vec[j], vec[j+1]); // 冒泡 flag = true; // 有交换，置flag为true &#125; &#125; if (!flag) break; // 如果没有交换，则说明剩下的元素已经是有序的，此时可直接退出循环 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); bubbleSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.6. 快速排序（Quick Sort）快速排序（Quicksort），又称划分交换排序（partition-exchange sort），是一种排序算法，它使用分治法策略来把一个序列分为两个子序列。它通常明显比其他$O(nlogn)$算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 算法步骤： 从数列中挑出一个元素，称为基准（pivot）； 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 【注】：基准的选择可以选择数列的第一个元素或者最后一个元素或者中间的元素，更好的是选择这三个特殊元素按大小排列后，位于中间的那个元素。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ 空间复杂度：根据实现的方式不同而不同。 稳定性：不稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 内部排序算法：快速排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 将vec按照vec[low]元素的值分为左右两部分，左边的元素值都比vec[low]小，右边的元素值都比vec[high]大 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 * @return: 基准值所在的索引 */template&lt;typename T&gt;int partition(vector&lt;T&gt;&amp; vec, int low, int high)&#123; int pivotKey = vec[low]; while (low &lt; high)&#123; while (low &lt; high &amp;&amp; vec[high] &gt;= pivotKey) --high; swap(vec[low], vec[high]); while (low &lt; high &amp;&amp; vec[low] &lt;= pivotKey) ++low; swap(vec[low], vec[high]); &#125; return low;&#125;/* * @function: 用快速排序算法将vec序列中从low到high的子序列排序 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 */template&lt;typename T&gt;void qSort(vector&lt;T&gt;&amp; vec, int low, int high)&#123; if (low &lt; high)&#123; int pivot = partition(vec, low, high); qSort(vec, low, pivot-1); qSort(vec, pivot+1, high); &#125;&#125;/* * @function: 快速排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec)&#123; qSort(vec, 0, vec.size()-1);&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); quickSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.7. 归并排序（Merge Sort）归并排序（Merge Sort），是创建在归并操作上的一种有效的排序算法，效率为$O(nlogn)$。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。 归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 该算法可通过迭代法和递归法两种方法实现。 递归法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 迭代法步骤： 将序列每相邻两个数字进行归并操作，形成${\lceil}n/2{\rceil}$个序列，排序后每个序列包含两个元素； 将上述序列再次归并，形成${\lceil}n/4{\rceil}$个序列，每个序列包含四个元素； 重复步骤2，直到所有元素排序完毕。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(n)$ $O(nlogn)$ 空间复杂度：$O(n)$。 稳定性：稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* * 内部排序算法：归并排序（递归实现） */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 将vec[low:mid]和vec[mid+1:high]两部分合并为一个向量 * @param: vec: 待排序的序列 * @param: low: 第一个待排序序列的最左端的索引 * @param: mid: 第一个待排序序列的最右端的索引 * @param: high: 第二个待排序序列的最右端的索引 */template&lt;typename T&gt;void merge(vector&lt;T&gt;&amp; vec, int low, int mid, int high)&#123; int i = low, m = mid; int j = mid+1, n = high; vector&lt;T&gt; tempVec(high-low+1); int index = 0; while (i &lt;= m &amp;&amp; j &lt;= n)&#123; tempVec[index++] = (vec[i]&lt;=vec[j]) ? vec[i++] : vec[j++]; &#125; while (i &lt;= m)&#123; tempVec[index++] = vec[i++]; &#125; while (j &lt;= n)&#123; tempVec[index++] = vec[j++]; &#125; for (int k = 0; k &lt; tempVec.size(); ++k) vec[low++] = tempVec[k];&#125;/* * @function: 用归并排序算法将vec序列中从low到high的子序列排序 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 */template&lt;typename T&gt;void mSort(vector&lt;T&gt;&amp; vec, int low, int high)&#123; if (low &lt; high)&#123; int mid = low + (high-low)/2; mSort(vec, low, mid); mSort(vec, mid+1, high); merge(vec, low, mid, high); &#125;&#125;/* * @function: 归并排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec)&#123; mSort(vec, 0, vec.size()-1);&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); mergeSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.8. 计数排序（Counting Sort）计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。 计数排序不是比较排序，排序的速度快于任何比较排序算法。但是对于数据范围很大的数组，需要大量的时间和内存。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n+k)$ $O(n+k)$ $O(n+k)$ 空间复杂度：$O(n+k)$（k表示元素的范围大小，比如元素范围为i到i+k-1）。 稳定性：稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 内部排序算法：计数排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 计数排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void countSort(vector&lt;T&gt;&amp; vec)&#123; if (vec.empty()) return; int size = vec.size(); T minElement = vec[0], maxElement = vec[0]; for (int i = 1; i &lt; size; ++i)&#123; if (vec[i] &lt; minElement) minElement = vec[i]; if (vec[i] &gt; maxElement) maxElement = vec[i]; &#125; vector&lt;int&gt; countVec(maxElement - minElement + 1); for (int i = 0; i &lt; size; ++i) ++countVec[vec[i]-minElement]; for (int i = 0, j = 0; i &lt; countVec.size(); ++i)&#123; while (countVec[i]--)&#123; vec[j++] = i+minElement; &#125; &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); countSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出： 10 1 2 3 4 5 6 7 8 9 2. 小结上述排序算法可分类如下： 插入排序类：插入排序，希尔排序 选择排序类：选择排序，堆排序 交换排序类：冒泡排序，快速排序 归并排序类：归并排序 前七中排序都是比较排序，而计数排序不是比较排序，其速度快于任何比较排序。 3. 参考资料 维基百科：插入排序 维基百科：希尔排序 维基百科：选择排序 维基百科：堆排序 维基百科：冒泡排序 维基百科：快速排序 维基百科：归并排序 维基百科：计数排序]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>内部排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的简单应用]]></title>
    <url>%2F2017%2F08%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E6%A0%88%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 栈的应用汇总 1.1. 括号匹配 1.2. 汉诺塔（Towers of Hnoi） 1.3. 迷宫老鼠 1. 栈的应用汇总1.1. 括号匹配问题描述：判断一个字符串的左右括号是否匹配。输入是一个字符串，输出是 true 或者 false。 求解策略：如果从左到右地扫描一个字符串，那么每一个右括号都与最近扫描的那个未匹配的左括号相匹配。我们可以从左到右扫描，将扫描到的左括号保存在栈中。每当扫描到一个右括号，就将它与栈顶的左括号（如果存在）相匹配，并将匹配的左括号从栈顶删除。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;/* 判断表达式中括号匹配 */bool printMatchedPairs(string expr)&#123; stack&lt;int&gt; s; int length = expr.size(); for (int i = 0; i &lt; length; ++i)&#123; if (expr.at(i) == '(') s.push(i); else if (expr.at(i) == ')')&#123; if (s.empty()) return false; else s.pop(); &#125; &#125; if (!s.empty()) return false; return true;&#125;int main(int argc, char **argv)&#123; // 括号匹配 string expr; cin &gt;&gt; expr; cout &lt;&lt; expr &lt;&lt; " matched is " &lt;&lt; printMatchedPairs(expr) &lt;&lt; endl; return 1;&#125; 时间复杂度：上述代码的时间复杂度为 O(n)，其中 n 为输入表达式的长度。 1.2. 汉诺塔（Towers of Hnoi）问题描述：假设有 n 个碟子和 3 座塔。初始时所有碟子从大到小堆在塔 1 上，我们要把碟子都移动到塔 2 上，另有塔 3 做为中转站。移动中要求： 每次移动一个； 任何时候都不能把大碟子压在小碟子上面。 求解策略：一个简洁的解决方法是递归。为了把最大的碟子移动到塔 2 的底部。必须把其余 n-1 个碟子移动到塔 3，然后把最大的碟子移动到塔 2。接下来是把塔 3 上的 n-1 个碟子移到塔 2。为此可以利用塔 2 和塔 1。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;/* 汉诺塔 */// 直接递归void towersOfHanoi(int n, char x, char y, char z)&#123; // 将塔 x 顶部的 n 个盘子移到塔 y，用 塔 z 作为中转地 if (n == 1)&#123; cout &lt;&lt; x &lt;&lt; " -&gt; " &lt;&lt; y &lt;&lt; endl; &#125;else&#123; towersOfHanoi(n-1, x, z, y); cout &lt;&lt; x &lt;&lt; " -&gt; " &lt;&lt; y &lt;&lt; endl; towersOfHanoi(n-1, z, y, x); &#125;&#125;int main(int argc, char **argv)&#123; int num = 0; cim &gt;&gt; num; towersOfHanoi(num, 'a', 'b', 'c'); return 1;&#125; 时间复杂度：上述程序的运行时间正比于输出的信息行数目，而信息行数目等于碟子移动的次数。分析可知，碟子移动次数的递归式 $moves(n)$： $$moves(n) = \begin{cases}0, &amp; \text{n is equal to 0} \ 2moves(n-1)+1, &amp; \text{n is greater than 0}\end{cases}$$ 计算这个公式，可以得到结果为 $moves(n)=2^n-1$。可以证明，$2^n-1$ 实际上是最少的移动次数。可以判定函数 towerOfHanoi 的复杂度为 $O(2^n)$。 1.3. 迷宫老鼠问题描述：迷宫（maze）是一个矩形区域，有一个入口和一个出口。迷宫内部包含不能穿越的墙壁或障碍物。这些障碍物沿着行和列放置，与迷宫边界平行。迷宫的入口在左上角，出口在右下角。迷宫老鼠（rat in a maze）问题是要寻找一条从入口到出口的路径。路径是一个由位置组成的序列，每一个位置都没有障碍，而且除入口之外，路径上的每一个位置都是前一个位置在东南西北方向上相邻的一个位置。 假设迷宫是个 n*n 的方阵，且足够小（能够存储在目标计算机内存中）。在矩阵中，当且仅当在位置 (i, j) 处有一个障碍时，其值为1，否则其值为0。 1234 _________________________入口 ||||| ||||| 入口 0 1 0 0 0 1 | ||||| ||||| ||||| 0 1 0 1 0 1 |___________|||||________ 出口 0 0 0 1 0 0 出口 求解策略：这个求解有三个步骤：输入迷宫、寻找路径和输出路径。本文只讨论寻找路径模块。 寻找路径：首先把迷宫入口作为当前位置。如果当前位置是迷宫出口，那么已经找到一条路径，寻找工作结束。如果当前位置不是迷宫出口，则在当前位置放置障碍物，以阻止寻找过程中又绕回到这个位置。然后检查相邻位置是否有空闲，如果有，就移动到一个空闲的相邻位置上，然后从这个位置开始寻找通往出口的路径。如果不成功，就选择另一个空闲的相邻位置，并从它开始寻找通往出口的路径。为了方便移动，在进入新的相邻位置之前，把当前位置保存在一个栈中。如果所有空闲的相邻位置都已经被探索过，但还未找到路径，则表明迷宫不存在从入口到出口的路径。 在迷宫的内部位置开始，有4中可能的移动方向：上下左右。从迷宫的边界开始，只有两种或三种可能的移动方向。为了避免在处理内部位置和边界位置时存在的差别，可以在迷宫周围增加一圈障碍物。对于 m*m 的数组 maze，这一圈障碍物将占据数组 maze 的第 0 行，第 m+1 行，第 0 列，第 m+1 列。这样，从迷宫的每个位置都有 4 种可能的移动方向，所以程序不需要处理边界条件，大大简化了代码设计。 每个迷宫位置都可以用行和列的下标来表示，分别称为迷宫位置的行坐标的列坐标。可以定义一个带有数据成员 row 和 col 的类 position，使用它的对象来跟踪记录迷宫位置。用数组表示栈，栈用来存储从入口到当前位置的路径。 要确定从位置 here 开始向哪一个相邻位置移动，可以用下表的偏移量表来计算。在下表中，offset[i].row 和 offset[i].col 分别是从当前位置沿方向 i 移动到下一个相邻位置时，row 和 col 坐标的增量。 移动 方向 行偏移量 列偏移量 0 右 0 1 1 下 1 0 2 左 0 -1 3 上 -1 0 为了不重蹈已经走过的位置，在每一个走过的位置 maze[i][j] 上设置障碍物（即令 maze[i][j]=1）。 title='main.cpp'123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 寻找迷宫路径代码 */typedef struct position&#123; int row; int col;&#125;position;vector&lt;vector&lt;bool&gt; &gt; maze; // 迷宫，假设是正方形int size = maze.size(); // 迷宫大小bool findPath()&#123; // 寻找一条从入口（1，1）到达出口（size，size）的路径 // 如果找到，返回true，否则返回false stack&lt;position&gt; *path = new stack&lt;position&gt;; // 初始化偏移量 position offset[4]; offset[0].row = 0; offset[0].col = 1; // 右 offset[1].row = 1; offset[1].col = 0; // 下 offset[2].row = 0, offset[2].col = -1; // 左 offset[3].row = -1; offset[3].col = 0; // 上 // 初始化迷宫外围的障碍墙 for (int i = 0; i &lt;= size + 1; ++i)&#123; maze[0][i] = maze[size + 1][i] = 1; // 底部和顶部 maze[i][0] = maze[i][size + 1] = 1; // 左和右 &#125; position here; here.row = 1; here.col = 1; maze[1][1] = 1; int option = 0; // 防止回到入口 int lastOption = 3; // 下一步 // 寻找一条路径 while (here.row != size || here.col != size)&#123; // 没有达到出口，找到要移动的相邻的一步 int r, c; while (option &lt;= lastOption)&#123; r = here.row + offset[option].row; c = here.col + offset[option].col; if (maze[r][c] == 0) break; ++option; &#125; // 相邻的一步是否找到 if (option &lt;= lastOption)&#123; // 移动到maze[r][c] path-&gt;push(here); here.row = r; here.col = c; maze[r][c] = 1; // 设置为1，避免重复访问 option = 0; &#125;else&#123; // 没有邻近的一步可走，返回 if (path-&gt;empty()) return false; // 没有位置可返回 position next = path-&gt;top(); path-&gt;pop(); if (next.row == here.row) option = 2 + next.col - here.col; else option = 3 + next.row - here.row; here = next; &#125; &#125; return true; // 到达出口&#125; 时间复杂度：程序的时间复杂度应为 O(unblocked)，其中 unblocked 是迷宫的空闲位置数目。这个复杂度为 O(szie^2) = O(m^2)。]]></content>
      <categories>
        <category>数据结构笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法和分支定界法概述]]></title>
    <url>%2F2017%2F08%2F24%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. 概述 2. 回溯法 2.1. 算法思想 2.2. 优化策略 2.3. 小结 3. 分支定界法 3.1. 算法思想 4. 总结 1. 概述要求解一个问题，最可靠的一种方法是：列出所有候选解，然后逐个检查，在检查所有或部分候选解之后，便可找到所需要的解。理论上只要候选解数量有限，这种方法就是可行的。不过实际中，这种方法很少用，因为候选解的数量通常都非常大（比如是实例大小的指数级，甚至是阶乘），无法在合理的时间内解决。 回溯法和分支定界法是对候选解进行系统检查的两种方法。这两种方法使最坏情况和一般情况下的求解时间大大减少。事实上，这两种方法可以省去对很大一部分候选解的检查，同时还能够找到所需要的解。一般回溯法使用深度优先方法搜索树，而分支定界法使用广度优先或最小耗费方法搜索树。 当需要求解NP-复杂问题的最优解时，使用回溯法和分支定界法来系统检查候选解经常可以得到最好的算法。相对而言，分支定界法的空间需求比回溯法要大得多，因此当内存容量有限时，回溯法常常更容易成功。 2. 回溯法2.1. 算法思想回溯法（backtracking）是搜索问题解的一种系统的方法。回溯法的步骤如下： 首先需要定义问题的一个解空间（solution space），这个空间至少包含问题的一个解。比如在$n$个对象的01背包问题中，可以把$2^n$个长度为$n$的01向量的集合定义为解空间，这个解空间集合代表着向量$x$取值0或1的所有可能。当$n=2$时，解空间为{(0,0),(0,1),(1,0),(1,1)}； 组织解空间，使解空间便于搜索。典型的组织方法时图或树。如下图是用树形结构描述两个对象的01背包问题的解空间，每条边，向左表示1，向右表示0。从根结点到叶节点的每条路径都是解空间的一个元素。从根节点A到叶节点E的路径所表示的解为$x=[1,0]$。根据实际情况，从根节点到叶节点的路径中一部分或全部都可能不是解。 12345 A / \ B C / \ / \D E F G 每条边向左表示1，向右表示0. 一旦确定了解空间，这个空间即可按深度优先方式从开始节点进行搜索。开始节点既是一个活动节点（live node）又是一个E-节点（expansion node）。从E-节点试着移到一个新节点。如果从当前的E-节点移到一个新节点，那么这个新节点就变成一个活动节点和新的E-节点，而原来的E-节点仍是一个活动节点。如果不能移到一个新节点，那么当前节点就“死掉”，即不再是活动节点。然后返回到最近的活动节点，这个活动节点就变成了新的E-节点。当已经找到了答案或者不再有活动节点时，搜索过程结束。在上述问题中，开始节点即是根节点。 当问题需要$n$个元素的一个子集来优化函数时，解空间树称为子集树（subset tree）。比如01背包问题，解空间树便是一个子集树。这样一颗树有$2^n$个叶节点，全部节点有$2^n-1$个。因此，访问树中所有节点的每一个算法都要耗时$O(2^n)$。 当问题需要$n$个元素的一个排列来优化函数时，解空间树称为排列树（permutation tree）。比如旅行商问题，解空间树便是一颗排列树。这样的树有$n!$个叶节点，遍历树中所有节点的每一个算法都要耗时$O(n!)$。 2.2. 优化策略确定一个新到达的节点能否导致一个比当前最优解还要好的解，可加速对最优解的搜索过程。如果不能，则移动到该节点的任何一颗子树都是无意义的，这个节点可被立即“杀死”。用来杀死活动节点的策略称为界定函数（bounding function）。比如01背包问题中，杀死那些不可行解的节点。 2.3. 小结回溯法的步骤如下： 定义一个解空间，它包含对问题实例的解； 用适合于搜索的方式组织解空间； 用深度优先方式搜索解空间，利用界定函数避免进入无解的子空间。 3. 分支定界法3.1. 算法思想分支定界法（branch and bound）是另一种系统地搜索解空间的方法。它与回溯法的主要区别在于E-节点的扩充方式。当一个节点变为E-节点时，从该节点移动一步即可到达的节点都是生成的新节点。在生成的节点中，那些导出可行解的节点被舍弃，剩余节点加入活动列表，然后从表中选择一个节点作为下一个E-节点。将选择的节点从表中删除，然后扩展该节点。这种扩展过程一直持续到一个解找到了或活动表表成为空表。 有两种常用的方法可用来选择下一个E-节点： 先进先出（FIFO）：从活动节点表中取出节点的顺序与加入节点的顺序相同。活动节点表于队列相同。 最小耗费或最大收益法：每个节点都有一个对应的耗费或收益。若搜索的是耗费最小的解，则活动节点表可以组织成最小堆，下一个E-节点是耗费最小的活动节点。若搜索的是收益最大的解，则活动节点表可以组织成最大堆，下一个E-节点是收益最大的活动节点。 4. 总结一般来说，在内存利用方面，回溯法优于分支定界法。回溯法需要的内存是O(解空间的最长路径长度)，而分支定界法所占用的内存为O(解空间大小)。因此在实际应用中，在回溯法还没有超出时间的上限之前，分支定界法已经超出了内存的上限。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01背包问题]]></title>
    <url>%2F2017%2F08%2F24%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 背包问题 1.1. 问题描述 1.2. 求解策略 1.2.1. 贪婪法 1.2.2. 动态规划法 1.2.3. 回溯法 1.2.4. 分支定界法 1.3. 小结 2. 参考资料 1. 背包问题1.1. 问题描述有$N$件物品和一个最大载重量为$W$的背包（容量不计），其中第$i$件物品的重量为$weights[i]$，价值为$profits[i]$，求解在不超过背包最大载重量的前提下，将哪些物品装入背包可使总价值最大。问题的公式描述是： $${\max}{\sum}_{i=0}^{N-1}{p_i}{x_i}$$ $$\text{s.t.}\;\;{\sum}_{i=0}^{N-1}{w_i}{x_i}\;\;\;{x_i{\in}{0,1}}$$ 其中$p_i$表示第$i$件物品的价值，$w_i$表示第$i$件物品的重量。要求的就是向量$x$。 1.2. 求解策略01背包的特点是：每种物品仅有一件，可以选择放还是不放。 下述分别用贪婪法、动态规划法、回溯法和分支定界法来给出求解策略。其中贪婪法不能保证一定获得最优解，但是它能非常接近最优解，而且有较好的性能。其它三种算法都能获得最优解。 1.2.1. 贪婪法01背包有若干种贪婪策略： 价值贪婪准则：从剩余物品中选出可以装入背包的价值最大的物品。 重量贪婪准则：从剩余的物品中选出可装入背包的重量最小的物品。 价值密度$p_i/w_i$贪婪准则：从剩余物品中选出可装入背包的$p_i/w_i$值最大的物品。 通过简单的分析可知，上述三种贪婪策略都不能保证得到最优解。但是价值密度贪婪准则是一个好的启发式算法，在更多时候，它的解非常接近最优解。而且该算法能在$O(nlogn)$时间内完成，这是非常好的性能。 由于三种算法思路简单，易于实现，在此不在贴出代码。 1.2.2. 动态规划法定义状态：$dp(i,j)$表示将前$i$个物品装入最大载重量为$j$的背包中所能获得的最大价值。 根据状态可分析：当要抉择是否要装入第$i$件物品时，可分两种情况，一种是不装入，则$dp(i,j)=dp(i-1,j)$；另一种是装入，则最大价值为装入前$i-1$件物品能获得的最大价值加上第$i$件物品的价值，即$dp(i,j)=dp(i-1,j-weights(i))+profits(i)$。考虑两种情况中能获得较大价值的那种情况，即为要选择的策略。 所以状态转移方程为： $$dp(i,j)=\begin{cases} \max{dp(i-1,j), dp(i-1,j-weights(i-1))+profits(i-1)}, &amp; \text{j &gt;= weights(i-1)} \ dp(i-1,j), &amp; \text{0 &lt;= j &lt; weights(i-1)} \end{cases}$$ 如果用$x[0:N-1]$表示装入的最佳策略，其中如果装入第$i$件物品x[i]=1，否则x[i]=0。则通过上述分析可知，当$dp(i,W)=dp(i-1,W)$时，没有装入第$i$件物品，否则就应该装入第$i$件物品。 通过上述分析，代码如下（这里假设背包最大载重量、物品重量、价值都是整数）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 01背包问题 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/* * @param: W: 背包的最大承重量 * @param: weights: 每件物品的重量 * @param: profits: 每件物品的价值 * @parma: x: 容量为N的向量，当x[i]=1表示装入第i件物品，x[i]=0表示不装入该物品 * @param: return: 返回最大价值 */int maxProfit(int W, vector&lt;int&gt;&amp; weights, vector&lt;int&gt;&amp; profits, vector&lt;bool&gt;&amp; x)&#123; int size = profits.size(); if (weights.size() != size) return -1; vector&lt;vector&lt;int&gt; &gt; dp(size+1, vector&lt;int&gt;(W+1)); for (int i = 0; i &lt;= size; ++i)&#123; for (int j = 0; j &lt;= W; ++j)&#123; if (i == 0) dp[i][j] = 0; if (i &gt; 0 &amp;&amp; j &gt;= weights[i-1]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+profits[i-1]); &#125; &#125; for (int i = 1; i &lt;= size; ++i)&#123; if (dp[i][W] == dp[i-1][W]) x[i-1] = 0; else x[i-1] = 1; &#125; return dp[size][W];&#125;int main(int argc, char** argv)&#123; int arr_weights[] = &#123;5, 4, 3, 2, 1&#125;; int arr_profits[] = &#123;20, 15, 10, 5, 1&#125;; vector&lt;int&gt; weights(arr_weights, arr_weights+sizeof(arr_weights)/sizeof(int)); // 每件物品的重量 vector&lt;int&gt; profits(arr_profits, arr_profits+sizeof(arr_profits)/sizeof(int)); // 每件物品的价值 int W = 9; // 背包总重量 vector&lt;bool&gt; x(sizeof(arr_weights)/sizeof(int)); // 用来存储是否装入第i件物品 cout &lt;&lt; maxProfit(W, weights, profits, x) &lt;&lt; endl; // 输出最大价值 for (int i = 0; i &lt; x.size(); ++i) // 输出装载策略 cout &lt;&lt; x[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 1;&#125; 代码输出：12351 1 0 0 0 可以发现上述程序时间复杂度为$O(NW)$，空间复杂度为$O(NW)$。其中时间复杂度不能再优化，但是空间复杂度可以再优化。 通过状态转移方程可知，$dp(i,j)$只与$dp(i-1,j)$和$dp(i-1,j-weights(i))$有关。可以只用一个一维向量$f[0:W]$来表示背包最大载重量为$0$到$W$时能获得的最大价值。然后不断更新该向量。比如，当放入前0件物品时，可以得到向量$f[0:W]$的值，当要放入前1件物品时，通过状态转移方程可知它只与放入前0件物品时的$f[0:W]$有关，此时状态转移方程为：$f(j):=\max{f(j),f(j-weights(0))+profits(0)}$。依次类推，可知当要装入前$i$件物品时，状态转移方程为： $$f(j) := \begin{cases}f(j), &amp; \text{j&gt;=weights(i-1)} \ f(j-weights(i-1))+profits(i-1), &amp; \text{0&lt;=j&lt;weights(i-1)}\end{cases}$$ 此时空间复杂度为$O(W)$，不过此时不能获知装入的策略。代码如下： 12345678910111213141516171819202122232425262728293031323334353637/* * 01背包问题 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/* * @param: W: 背包的最大承重量 * @param: weights: 每件物品的重量 * @param: profits: 每件物品的价值 * @parma: x: 容量为N的向量，当x[i]=1表示装入第i件物品，x[i]=0表示不装入该物品 * @param: return: 返回最大价值 */int maxProfit(int W, vector&lt;int&gt;&amp; weights, vector&lt;int&gt;&amp; profits)&#123; int size = profits.size(); if (weights.size() != size) return -1; vector&lt;int&gt; dp(W+1); for (int i = 0; i &lt;= size; ++i)&#123; for (int j = W; j &gt;= 0; --j)&#123; if (i == 0) dp[j] = 0; if (i &gt; 0 &amp;&amp; j &gt;= weights[i-1]) dp[j] = max(dp[j], dp[j-weights[i-1]]+profits[i-1]); &#125; &#125; return dp[W];&#125;int main(int argc, char** argv)&#123; int arr_weights[] = &#123;5, 4, 3, 2, 1&#125;; int arr_profits[] = &#123;20, 15, 10, 5, 1&#125;; vector&lt;int&gt; weights(arr_weights, arr_weights+sizeof(arr_weights)/sizeof(int)); // 每件物品的重量 vector&lt;int&gt; profits(arr_profits, arr_profits+sizeof(arr_profits)/sizeof(int)); // 每件物品的价值 int W = 9; // 背包总重量 cout &lt;&lt; maxProfit(W, weights, profits) &lt;&lt; endl; // 输出最大价值 return 1;&#125; 代码输出：135 1.2.3. 回溯法01背包问题是选择一个物品的子集，来装入背包，以便获取最大价值，则解空间就应该组织成子集树结构。然后采用深度优先遍历来探索该子集树。只要左孩子表示一个可行的节点，就沿着左分支移动；否则，当右子树可能含有优于当前最优解的解的时候，搜索右子树。是否要搜索右子树，一个简单的判定方法是，当前节点的收益加上还未考察的对象的收益是否超过当前最优解的收益，如果不是，则不需要搜索右子树。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * 01背包问题 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 全局变量int N; // 物品数量int W; // 背包最大载重量int remainingWeights; // 剩余的物品重量int currentWeights; // 当前的载重量int currentProfits; // 当前装载的价值int bestProfits; // 最大装载价值vector&lt;int&gt; weights; // 每件物品的重量vector&lt;int&gt; profits; // 每件物品的价值vector&lt;bool&gt; x; // 当前的策略vector&lt;bool&gt; bestX; // 最佳策略/* * @param: i: 第i层 */void rKnapsack(int i)&#123; if (i &gt;= N)&#123; // 回溯结束条件 if (currentProfits &gt; bestProfits)&#123; bestProfits = currentProfits; bestX = x; &#125; return; &#125; remainingWeights -= weights[i]; if (currentWeights + weights[i] &lt;= W)&#123; // 搜索左子树 x[i] = 1; currentWeights += weights[i]; currentProfits += profits[i]; rKnapsack(i+1); currentWeights -= weights[i]; currentProfits -= profits[i]; &#125; if (currentWeights + remainingWeights &gt; bestProfits)&#123; // 搜索右子树 x[i] = 0; rKnapsack(i+1); &#125;&#125;int main(int argc, char** argv)&#123; int arr_weights[] = &#123;5, 4, 3, 2, 1&#125;; int arr_profits[] = &#123;20, 15, 10, 5, 1&#125;; N = sizeof(arr_weights)/sizeof(int); W = 9; remainingWeights = 0; currentWeights = 0; currentProfits = 0; bestProfits = 0; weights.assign(arr_weights, arr_weights+N); profits.assign(arr_profits, arr_profits+N); x = vector&lt;bool&gt;(N); bestX = vector&lt;bool&gt;(N); for (int i = 0; i &lt; N; ++i) remainingWeights += weights[i]; rKnapsack(0); // 开始回溯 cout &lt;&lt; bestProfits &lt;&lt; endl; // 输出最大价值 for (int i = 0; i &lt; N; ++i) // 输出选择策略 cout &lt;&lt; bestX[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 1;&#125; 代码输出：12351 1 0 0 0 1.2.4. 分支定界法分支定界法和回溯法很相似，先将解空间构造为子集树，然后采用广度优先遍历来获取最佳策略。由于分支定界法占用内存大（需要存储将要扩展的节点），效率不高，所以不如回溯法。代码等以后补充。 1.3. 小结贪婪法是一种启发式算法，虽然不能保证获取最优解，但是能获得近似解，而且效率高，一般价值密度贪婪准则的实用效果更好。动态规划法是一种常用的算法，能获得最优解，而且直观、易于理解。回溯法和分支定界法都是将解空间构建为子集树，然后遍历搜索所有情况，相比于暴力搜索，这两种方法都采用界定函数来缩小搜索的范围（即去掉不必要搜索的节点），由于分支定界法的空间需求比回溯法要大的多，因此当内存容量有限时，回溯法更容易成功。 2. 参考资料 背包问题九讲]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL笔记之heap]]></title>
    <url>%2F2017%2F08%2F11%2FC-STL%E7%AC%94%E8%AE%B0%E4%B9%8Bheap%2F</url>
    <content type="text"><![CDATA[1. STL笔记之heap 1.1. 简介 1.2. 相关算法的使用 1. STL笔记之heap1.1. 简介heap（堆）是一种比较复杂的数据结构。不过 STL 已经封装了 heap 的一些操作，比如：创建堆、判断堆、插入一个元素、删除一个元素、以及堆排序。在 STL 中，heap 是以算法的形式提供的，包括下面几个函数： make_heap()：根据指定的迭代器区间以及一个可选的比较函数（通常为 greater&lt;T&gt;() 或者 less&lt;T&gt;()，其中 T 为一种数据类型），来创建一个 heap，时间复杂度为 O(n)； push_heap()：把指定区间的最后一个元素插入到 heap 中，时间复杂度为 O(logn)； pop_heap()：弹出 heap 顶元素，将其放置于区间末尾，时间复杂度 O(logn)； sort_heap()：堆排序算法，将指定区间的元素进行堆排序，时间复杂度为 O(nlogn)。 C++11 加入了两个新成员： is_heap()：判断给定区间是否是一个 heap，时间复杂度为 O(n)； is_heap_until()：找出区间中第一个不满足 heap 条件的元素，返回指向该元素的指针。时间复杂度为 O(n)。 因为 heap 都是以算法的形式提供，所以使用这几个函数需要包含如下头文件：1#include &lt;algorithm&gt; 1.2. 相关算法的使用使用数组来存储一个堆，也就是堆化数组：123int arr[] = &#123;2, 14, 4, 16, 6, 5, 3&#125;;vector&lt;int&gt; vec(arr, arr + sizeof(arr)/sizeof(int));// vector&lt;int&gt; vec&#123;2, 14, 4, 16, 6, 5, 3&#125;; 注：下述函数的使用都是代码片段，且使用的比较函数都是 greater&lt;T&gt;()，即小根堆，默认的是 less&lt;T&gt;()，即大根堆。完整代码在本文最后。 1. is_heap()：判断堆 原型：1234567// 1template&lt; typename RandomIt &gt;bool is_heap( RandomIt first, RandomIt last );// 2template&lt; typename RandomIt, typename Compare &gt;bool is_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1cout &lt;&lt; is_heap(vec.begin(), vec.end()) &lt;&lt; endl; 2. is_heap_until()：找出区间中第一个不满足 heap 条件的元素，返回指向该元素的指针。 原型：1234567// (1) (since C++11)template&lt; class RandomIt &gt;RandomIt is_heap_until( RandomIt first, RandomIt last );// (2) (since C++11)template&lt; class RandomIt, class Compare &gt;RandomIt is_heap_until( RandomIt first, RandomIt last, Compare comp ); 用法示例：12vector&lt;int&gt;::iterator iter = is_heap_until(vec.begin(), vec.end(), greater&lt;int&gt;());cout &lt;&lt; "is heap until: " &lt;&lt; *iter &lt;&lt; endl; 3. make_heap()：构造堆 STL 中的通过 make_heap() 创建的堆，默认是大根堆（max heap）。要改变堆的建立准则，可以自己制定一个比较函数，比如如下第二个版本的第三个参数。第三个参数可填：less&lt;int&gt;() 构造大根堆，greater&lt;int&gt;() 构造小根堆。（注意：要使用其中一个比较函数，在该堆上使用的其他算法也要使用该比较函数） 原型：1234567// 1template&lt; class RandomIt &gt;void make_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void make_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1make_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 4. push_heap()：插入元素 如果要在堆中插入一个元素，首先要往容器 vector 尾部插入一个元素，然后把新的迭代区间传给 push_heap()，这样新的元素也被插入到堆中。时间复杂度为 O(logn)。 原型：1234567// 1template&lt; class RandomIt &gt;void push_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void push_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：12vec.push_back(20);push_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 5. pop_heap()：弹出元素 弹出的元素默认是根节点的元素。这个算法的作用是交换根结点元素与堆中的最后一个元素，然后把除了尾部元素的剩余区间重新调整成堆。注意，pop_heap() 函数并没有真正的删除元素，最后要使用容器的 pop_back() 来删除元素。 原型：12345678910// 1 template&lt; class RandomIt &gt;void pop_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void pop_heap( RandomIt first, RandomIt last, Compare comp );// Swaps the value in the position first and the value in the position last-1 and makes the subrange [first, last-1) into a max heap. // This has the effect of removing the first (largest) element from the heap defined by the range [first, last). 用法示例：12pop_heap(vec.begin(), vec.end(), greater&lt;int&gt;());vec.pop_back(); 6. sort_heap()：堆排序 该算法实现经典的堆排序算法，通过每次弹出堆顶元素直到堆为空，依次被弹出的元素就组成了有序的序列。STL 中的 priority_queue 既是用 heap 的这个特性来实现的。 注意：使用 sort_heap() 时要确保区间已经是一个堆了，处理过后的区间因为有序，就不再是一个 heap 了。 原型：1234567// 1template&lt; class RandomIt &gt;void sort_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void sort_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1sort_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 7. 完整代码示例：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i)&#123; out &lt;&lt; vec[i] &lt;&lt; ' '; &#125; return out;&#125;int main(int argc, char **argv)&#123; // int arr[] = &#123;2, 14, 4, 16, 6, 5, 3&#125;; // vector&lt;int&gt; vec(arr, arr + sizeof(arr)/sizeof(int)); vector&lt;int&gt; vec&#123;2, 14, 4, 16, 6, 5, 3&#125;; cout &lt;&lt; "is heap: " &lt;&lt; is_heap(vec.begin(), vec.end()) &lt;&lt; endl; make_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "make heap: " &lt;&lt; vec &lt;&lt; endl; vec.push_back(20); push_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "push heap: " &lt;&lt; vec &lt;&lt; endl; pop_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); vec.pop_back(); cout &lt;&lt; "pop heap: " &lt;&lt; vec &lt;&lt; endl; sort_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "sort heap: " &lt;&lt; vec &lt;&lt; endl; vector&lt;int&gt;::iterator iter = is_heap_until(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "is heap until: " &lt;&lt; *iter &lt;&lt; endl; return 0;&#125; 代码输出为（注意，g++ 编译时需要添加 -std=c++11）：123456is heap: 0make heap: 2 6 3 16 14 5 4push heap: 2 6 3 16 14 5 4 20pop heap: 3 6 4 16 14 5 20sort heap: 20 16 14 6 5 4 3is heap until: 16]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++之回调函数]]></title>
    <url>%2F2017%2F08%2F11%2FC-c-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. c++之回调函数 1.1. 回调函数 1.2. c++中回调函数的使用 1. c++之回调函数1.1. 回调函数回调函数就是在调用某个函数B时，将自己的一个函数A的地址作为参数传递给函数B，函数B在执行的过程中，通过那个函数指针参数反过来调用函数A，即被调用者回头调用调用者的函数，故其称为回调函数（callback function）。 比如一般的API提供方无法知道用户会怎样使用数据，它就会让用户自己设计处理数据的函数，并将该函数的地址作为参数传递给API接口，API接口获取数据后调用传递给它的函数来实现用户自定义的数据处理方式。即用户调用服务方的API接口，它又反过来调用用户自定义的函数。 1.2. c++中回调函数的使用在C语言中可像普通函数一样使用回调函数，只须把回调函数定义为全局的即可。而在C++中的类成员函数中使用回调函数会发生错误。这是因为普通的C++成员函数都隐含了一个传递函数作为参数，即this指针，C++通过传递this指针给其成员函数从而实现成员函数的调用（每个成员函数都需要一个对象去调用它）。由于this指针的作用，使得将一个callback型的成员函数作为回调函数时就会因为隐含的this指针使得函数参数个数不匹配，从而导致回调函数调用失败。（我的理解是：如果在API提供方提供的函数中调用类的成员函数，必需传递一个类的实例的指针，通过这个类的实例指针来调用该成员函数，否则在类外无法在没有类实例的情况下直接调用其成员函数）。 要解决这一问题，有三种方法： 1. 不使用成员函数，即将回调函数定义为全局的，像C语言一样使用回调函数（这样有个问题就是无法访问类的成员变量）： 代码示例如下：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;//---------------------------------// 这个是回调函数void callbackFun(int a)&#123; cout &lt;&lt; "callbackFun: " &lt;&lt; a &lt;&lt; endl;&#125;class testClass&#123;public: void start(pFun f, int a)&#123; fun(f, a); &#125;private:&#125;;int main()&#123; fun(callbackFun, 10); // C 的用法 testClass aaa; aaa.start(callbackFun, 6); // 在类中调用全局的回调函数 return 1;&#125; 代码输出：12callbackFun: 10callbackFun: 6 2. 不使用成员函数，为了访问类的成员变量，使用友元操作符(friend)，在C++中将该函数说明为类的友元即可。 代码示例如下：12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);void callbackFun(int); // 回调函数声明// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;// 测试类class testClass&#123;public: testClass(int a) : m(a) &#123;&#125; friend void callbackFun(int a); // 友元private: int m;&#125;;//---------------------------------// 这个是回调函数void callbackFun(int a)&#123; testClass aaa(a); cout &lt;&lt; "callbackFun aaa.m: " &lt;&lt; aaa.m &lt;&lt; endl; // 访问类的私有成员&#125;int main()&#123; fun(callbackFun, 10); return 1;&#125; 代码输出：1callbackFun aaa.m: 10 3. 回调函数必需是类的成员函数，将其设计为静态成员函数，静态成员函数不使用this指针作为隐含变量，这样就可以作为回调函数了。但这样有一个严重的缺点：静态成员函数只能访问类的静态成员变量和静态成员函数，不能访问非静态的。可以通过设计一个静态类指针作为类成员来解决，通过在类创建时初始化该静态指针，然后在回调函数中通过该静态指针来访问所有成员变量和成员函数了。 代码示例如下：&#123;.line-numbers&#125;123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;class testClass&#123;public: testClass(int a) : m(a) &#123;&#125; // 回调函数 static void callbackFun(int a)&#123; cout &lt;&lt; "callbackFun a: " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "m: " &lt;&lt; pTestClass-&gt;m &lt;&lt; endl; &#125; void start(pFun f, int a)&#123; pTestClass = this; // 将该this指针赋给静态类指针 fun(f, a); &#125;private: int m; static testClass* pTestClass; // 静态类指针&#125;;testClass* testClass::pTestClass = NULL;int main()&#123; testClass aaa(10); aaa.start(testClass::callbackFun, 6); return 1;&#125; 代码输出：12callbackFun a: 6m: 10 但是上述方法只能适用于一个实例的情况，因为多个实例将共享静态成员变量。为了避免这种情况，可以使用回调函数的一个参数来传递this指针，从而实现数据成员共享。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-Face Image Quality Assessment Based on Learning to Rank(by Jiansheng Chen)]]></title>
    <url>%2F2017%2F07%2F13%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Face-Image-Quality-Assessment-Based-on-Learning-to-Rank-JianshengChen%2F</url>
    <content type="text"><![CDATA[1. 摘要 1.1. 介绍 1.2. 人脸标准化 1.3. 人脸质量评价 1.4. 实验 1.5. 总结 2. 参考文献 1. 摘要人脸图像质量是人脸识别准确性的重要影响因素之一。在实际识别系统中通常会抓取到不同场景下的多张人脸，从多张人脸图像中选择一张高质量图像去识别对提高系统的性能是非常有用的策略。本文提出了一种基于 learning to rank 的框架去评估人脸图像质量。这种方法很简单，并且能够自适应不同的识别方法。实验结果证明了它在提高人脸检测及识别的鲁棒性上非常有效。 关键字：人脸质量，人脸识别，learing to rank 1.1. 介绍对个人身份验证来说，人脸被普遍认为是一种理想的生物识别特征，因为它是普遍的、有区别的、非侵入式的并且容易获取。在过去的二十年，自动人脸识别技术吸引了大量的关注，不管是学术界还是工业界，提出了很多基于人脸图像的人脸识别 (identifying) 和身份认证 (verifying) 方法。然而，人脸识别仍是一项富有挑战性的任务，因为在自然环境下采集的人脸图像会由于光照、姿态、遮挡、表情的不同产生不同的图像。这些问题在实际的应用程序中会由于不配合的用户以及不可控的环境造成非常严重的影响。虽然很多提出了很多方法来提高人脸识别的鲁棒性去对抗不同质量的人脸图像，但普遍认为人脸识别还是在高质量人脸图像上表现出更好的性能。 1.2. 人脸标准化仅仅位于人脸内部的像素点应该用来评估人脸质量。这可以实现，比如，通过定位人脸轮廓的标志点，图像中的每张脸可以产生一个特殊的标注。然而，这很耗时，并且由于不规则的轮廓，对后面的特征提取造成很大的困难。另一方面，许多人脸检测器简单的输出方形包围框，这明显偏离了人脸的轮廓，并且涵盖了大量的非人脸信息。此外，面部旋转也应该作为质量评估的影响因素之一，因为很多人脸识别系统都能够处理。基于上述所有的考虑，本文提出了人脸标准化过程，见 Fig.1. Fig.1(a) 展示了人脸检测的结果，该人脸来自 LFW 人脸数据集。然后将检测到的人脸区域调整到 $68\times68$ 像素，输入一个 CNN 网络来获取标志点位置。本文用眼角和嘴角，因为这些点可以清晰的标注，并且涵盖的区域包含了人脸的大部分区域。Fig.2 展示了 CNN 的网络结构，它包含了三个卷积层以及三个降采样层，卷积核是 $5\times5$，输出是标志点坐标。本文从 LFW 数据集中随机选择了 10000 幅图像用来训练，剩下的用来测试。在测试集上，标志点的位置偏差平均是 1.4 个像素。Fig.1(b) 显示了标注的标志点。 为了标准化人脸区域，并且消除旋转的影响，本文首先计算中心点 $C$ 以及用 linear time algorithm 方法得到的涵盖所有标志点的最小的圆的半径 $r$。然后以点 $C$ 为中心取一个大小为 $2.4r\times4r$ 的矩形 $R$ (见图Fig.1(c))。显然所有的标志点都包含在 $R$ 中。设四个眼角的坐标是 $[x_i, y_i], (i = 1,2,3,4)$，矩形的方向由公式 $(1)$ 决定，这样矩形 $R$ 的宽平行于四个眼角构成的直线。Fig.1(d) 中的标准脸就可以由矩形区域 $R$ 围绕 $C$ 旋转 $\theta$ 角得到。 其中 $\overline{x}$ 和 $\overline{y}$ 分别表示水平和垂直方向的均值。 更多的 LFW 图像的标准化结果如图 Fig.1(e)(f)(g)，可以看到标准化的脸更紧凑，并确保包含了人脸的主要部分。标准化过后的脸之后被用于人脸质量评估的输入。这个标准化方法对于一些不准确的标志点来说是有点健壮的。然而，当出现多个标志点位置不准确的情况，标准化的结果可能会恶化，并导致人脸质量评估的结果效果很差。然而这个问题是可以容忍的，因为这大多数情况下，这种情况确实表明人脸图像的质量很低。 1.3. 人脸质量评价一般很难精确的定义量化人脸图像质量。在过去的研究中，解决此问题主要有两种方案。第一种是利用面部的一些特性，比如分辨率、姿态角度、或者光照参数，利用这些去量化人脸图像质量；另一种是选择一张“标准脸”，用人脸图像与这张“标准脸”的差异来度量人脸质量。这两种方法都比较僵化，缺乏适用性，因为它们都没有考虑人脸识别方法可能带来的差异。比如有一种人脸识别算法适用于解决遮挡问题，那么 Fig.1(g) 可能比 Fig.1(f) 表现的更好。相反的，有一种人脸识别算法适用于解决姿态问题，则 Fig.1(f) 具有更高的图像质量。因此，要以相对的方式去考虑人脸图像质量。对大多数人脸识别方法，考虑图像质量，Fig.1(d) 比 Fig.1(f) 要好，但是比 Fig.1(e) 要差。 基于上述的考虑，本文提出了一种基于 learning to rank 的简单的、灵活的人脸图像质量评价方法。假设有一种人脸识别方法在两个不同的数据集 $A$ 和 $B$ 中测试，且识别的性能在 $A$ 上表现比 $B$ 好。这表明，对这种人脸识别方法，$A$ 中的图像比 $B$ 中的有更高的质量。我们标记这为 $A\succ B$，设 $I_i$ 和 $I_j$ 分别表示 $A$ 和 $B$ 中的一幅图像，$f()$ 表示将提取图像特征向量的函数，定义一种线性结构的质量评价函数 $S(I) = \omega^{T}f(I)$，目标就是求权重 $\omega$ 的值，使得其满足方程 $(2)$ 的约束。同时，在同一个人脸数据集中的图像应该具有相同的质量，这通过方程 $(3)\;(4)$ 来约束，本文称 $S(I)$ 的值为图像 $I$ 的 $RQS(Rank \; based \; Quality \; Score)$。 $$\omega^{T}f(I_i) &gt; \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{B}{\quad\quad}{\text{(2)}}$$ $$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{A}{\quad\quad}{\text{(3)}}$$ $$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{B},\;\forall{I_j}\in{B}{\quad\quad}{\text{(4)}}$$ 上述问题规划与文献 [23] 中的相同，因此可以转化为一个凸规划问题（见公式(5)），通过引入非负松弛变量 ${\lambda_1},\,{\lambda_2},\,{\lambda_3}$ 来平衡相关约束，由公式 (5) 定义的优化问题可以用 Newton 方法有效的解决。 本文提出的公式可以扩展至多数据集、多特征。对于多特征融合，采用两层学习策略。假设从图像 $I$ 中提取了 $m$ 个不同的特征，设与第 $i$ 个特征相关的质量评价函数为 $S_i(I)={\omega^T}f_i(I),\;{(i=1,2,\cdots,m)}$。在第一层学习中，所有的排序权重 $\omega_i$ 通过公式(5)学习到，设 $\vec{S_v} = {[{S_1(I)};{S_2(I)}\;\cdots\;{S_m(I)}]}^T$ 为包含第一层学习张由图像 $I$ 所有特征得到的 $RQS$ 的列向量。定义第二层 质量评估函数为 ${S_k(I)} = {\omegak}{f{\Phi}(\vec{Sv})}$，其中 $f{\Phi}()$ 为多项式核函数。本文中 $m=5$ 并且多项式核函数为二阶多项式核函数。$f_{\Phi}(\vec{S_v})$ 的表达式为公式(6)。 $\omega_k$ 的值可以通过二次训练得到，$S_k(I)$ 的值归一化到 $0~100$ 之间，并用来图像 $I$ 的最终得分。Fig.3 展示了计算 Fig.1(d) 的 $RQS$ 的计算过程。 1.4. 实验本文实验结果展示如图Fig.6。 1.5. 总结2. 参考文献]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人脸图片质量评估]]></title>
    <url>%2F2017%2F07%2F12%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%BA%E8%84%B8%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[1. 人脸图片质量评估 1.1. 参考资料 1. 人脸图片质量评估图片质量评估 算法分为：主观的和客观的。 人脸识别系统 的流程为：输入面部图片–&gt;人脸检测–&gt;质量评估–&gt;对质量较好的进行识别(不好的丢弃) 人脸图片质量特征 纹理特征(Texture)：对比度(Contrast)，压缩比(Compression ratio)，光照强度(Illuminance) 几何特征(Geometry)：对称性(Symmetry)，姿态(Pose)，旋转角度(Rotation)，双眼之间的距离(Eye visibility) 人脸图片质量评估 是基于排序学习(Learning to rank, 简称 L2R)。 1.1. 参考资料 Vladimir Khryashchev, Evaluation of Face Image Quality Metrics in Person Identification Problem Jiansheng Chen, Member, IEEE, Yu Deng, Gaocheng Bai, and Guangda Su, Face Image Quality Assessment Based on Learning to Rank]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt 界面样式设计]]></title>
    <url>%2F2017%2F07%2F06%2FC-Qt-%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1. Qt 界面样式设计 1.1. 控件样式设计 1.1.1. QLabel 样式 1.1.2. QComboBox 1.1.3. QEditLine 1.1.4. QCheckbox 1.1.5. QPushButton 1.1.6. QScrollBar 1.1.7. QTableWidget 1.2. 参考资料 1. Qt 界面样式设计1.1. 控件样式设计改变控件的样式一般使用 setStyleSheet(“”) 函数，其可填参数如下： 参数 效果说明 “background-color: rgb(0, 0, 0);” 设置 件的背景色为 QColor(0,0,0) “background: url(:/img/label_bg.png);” 用图片填充控件 “color: rgb(255, 255, 255);” 设置控件的文本颜色为 QColor(255,255,255) “font: bold 16px;” 设置控件中的文本字体为 16 号粗体 “border: 2px solid rgb(66, 169, 235);” 设置控件的边框宽度为 2px，颜色为 QColor(66,169,235) “border-radius: 4px;” 设置控件的边角为圆角 以下仅对具体控件的特殊样式设计进行说明。 1.1.1. QLabel 样式如果 style sheet 无法满足 QLabel 在应用的需求，可通过继承 QLabel 写自己新的 label 类。比如在 QLabel 的四个角画线，显示一种画框效果，可新建一个 MyQLabel 类，在类中重写 paintEvent(QPaintEvent *event) 函数即可。代码示例如下： 1234567891011121314151617181920void MyQLabel::paintEvent(QPaintEvent *event)&#123; QLabel::paintEvent(event); // 重要，先调用父类的 paintEvent() 为了显示原背景图像 int width = this-&gt;width(); int height = this-&gt;height(); QPainter painter(this); painter.setPen(QPen(QColor(66,169,235), 3)); painter.drawLine(QPointF(0, 0), QPointF(width/8, 0)); // 左上角横线 painter.drawLine(QPointF(0, 0), QPointF(0, height/8)); // 左上角竖线 painter.drawLine(QPointF(width, 0), QPointF(width*7/8, 0)); // 右上角横线 painter.drawLine(QPointF(width, 0), QPointF(width, height/8)); // 右上角竖线 painter.drawLine(QPointF(0, height), QPointF(width/8, height)); // 左下角横线 painter.drawLine(QPointF(0, height), QPointF(0, height*7/8)); // 左下角竖线 painter.drawLine(QPointF(width, height), QPointF(width*7/8, height)); // 右下角横线 painter.drawLine(QPointF(width, height), QPointF(width, height*7/8)); // 右下角竖线&#125; 效果如下（图中的照片是一张背景图）： 1.1.2. QComboBox参考链接：Qt Style Sheet实践（二）：组合框QComboBox的定制 1.1.3. QEditLine一般用 QEditLine 控件实现搜索框。 12345678910111213141516171819query_button = new QPushButton();query_button-&gt;setFixedWidth(50);query_button-&gt;setCursor(Qt::PointingHandCursor);query_button-&gt;setToolTip(tr("搜索"));// query_button-&gt;setFlat(true); // 实现按钮透明query_button-&gt;setStyleSheet("QPushButton&#123;background:url(:/button/button_search) center no-repeat; border: none;&#125;");query_edit = new QLineEdit();query_edit-&gt;setFixedWidth(530);query_edit-&gt;setPlaceholderText(tr("请输入要搜索的id"));query_edit-&gt;setStyleSheet("background-color: rgb(29,33,41); color: rgb(255,255,255); height: 35px; border: 1px solid rgb(66,169,235); border-radius: 6px;");QMargins margins = query_edit-&gt;textMargins(); // 设置文本与搜索框的边距，避免太靠近query_edit-&gt;setTextMargins(margins.left(), margins.top(), query_button-&gt;width(), margins.bottom());QHBoxLayout *query_edit_layout = new QHBoxLayout(); // 设置 query_edit 的布局query_edit_layout-&gt;addStretch();query_edit_layout-&gt;addWidget(query_button);query_edit_layout-&gt;setSpacing(0);query_edit_layout-&gt;setContentsMargins(0, 0, 5, 0);query_edit-&gt;setTextMargins(8, 0, 0, 0);query_edit-&gt;setLayout(query_edit_layout); 效果如下： 其他的样式设计可参考：Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全 1.1.4. QCheckbox 参数 效果说明 “QCheckBox::indicator {width: 20px; height: 20px;}” 设置勾选框的大小 “QCheckBox::indicator:unchecked {image: url(:/checkbox/unchecked);}” 设置勾选框未勾选时的效果 “QCheckBox::indicator:unchecked:hover {image: url(:/checkbox/unchecked_hover);}” 设置勾选框未勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:unchecked:pressed {image: url(:/checkbox/unchecked_press);}” 设置勾选框未勾选时鼠标点击状态下的效果 “QCheckBox::indicator:checked {image: url(:/checkbox/checked);}” 设置勾选框勾选时的效果 “QCheckBox::indicator:checked:hover {image: url(:/checkbox/checked_hover);}” 设置勾选框勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:checked:pressed {image: url(:/checkbox/checked_press);}” 设置勾选框勾选时鼠标点击状态下的效果 1.1.5. QPushButtonQPushButton 的独特的样式如下： 参数 效果说明 “QPushButton{background-color: rgb(66,169,235);}” 设置正常状态下 QPushButton 的背景色 “QPushButton:hover{background-color: rgb(60,195,245);}” 设置鼠标悬浮状态下 QPushButton 的背景色 “QPushButton:pressed{background-color: rgb(9,140,188);}” 设置鼠标点击状态下 QPushButton 的背景色 以上设置背景色的方法还可以改为设置图片，方法为：将 “background-color: rgb(66,169,235)” 改为 “border-image: url(:/pushbutton_normal.png)” 1.1.6. QScrollBar设置水平滚动条： 12345table_widget-&gt;horizontalScrollBar()-&gt;setStyleSheet("QScrollBar:horizontal&#123;background:rgb(32,36,45); padding-top:1px; padding-bottom:1px; padding-left:20px; padding-right:20px; border:1px solid rgb(38,42,53); height: 16px;&#125;" // 整体设置 "QScrollBar::handle:horizontal&#123;background:rgb(47,53,66); border-radius: 6px; border: 1px solid rgb(32,36,45);&#125;" // 设置滚动条 "QScrollBar::hadnle:horizontal:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:horizontal&#123;background:url(:/scrollbar/arrow_right) center on-repeat;&#125;" // 设置右箭头 "QScrollBar::sub-line:horizontal&#123;background:url(:/scrollbar/arrow_left) center no-repeat;&#125;"); // 设置左箭头 设置垂直滚动条： 12345table_widget-&gt;verticalScrollBar()-&gt;setStyleSheet("QScrollBar:vertical&#123;background:rgb(32,36,45); padding-top:20px; padding-bottom:20px; padding-left:1px; padding-right:1px; border:1px solid rgb(38,42,53); width: 16px;&#125;" // 整体设置 "QScrollBar::handle:vertical&#123;background:rgb(47,53,66); border-radius: 6px; border: none;&#125;" // 设置滚动条 "QScrollBar::hadnle:vertical:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:vertical&#123;background:url(:/scrollbar/arrow_down) center on-repeat;&#125;" // 设置下箭头 "QScrollBar::sub-line:vertical&#123;background:url(:/scrollbar/arrow_up) center no-repeat;&#125;"); // 设置上箭头 QScrollBar 的一些样式属性说明： 1.1.7. QTableWidget设置表格样式： 123table_widget-&gt;setStyleSheet("selection-background-color: rgb(0, 120, 215)"); // 设置选中时的背景色table_widget-&gt;setStyleSheet("QWidget&#123;background-color: rgb(32,37,45)&#125;" // 设置普通状态下的背景色 "QTableWidget::item&#123;border-top: 1px solid rgb(38, 42, 53); border-bottom: 1px solid rgb(38, 42, 53)&#125;"); // 设置表格单元格 1.2. 参考资料 Qt Style Sheets Reference Qt Style Sheets Examples The Style Sheet Syntax Qt控件美化 Qt Style Sheet实践（一）：按钮及关联菜单 Qt Style Sheet实践（二）：组合框QComboBox的定制 Qt Style Sheet实践（三）：QCheckBox和QRadioButton Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>界面样式</tag>
      </tags>
  </entry>
</search>