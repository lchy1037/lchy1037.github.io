<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内部排序算法汇总]]></title>
    <url>%2F2017%2F08%2F25%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 常见的内部排序算法汇总-C++描述 1.1. 插入排序（Insertion Sort） 1.2. 希尔排序（Shell Sort） 1.3. 选择排序（Selection Sort） 1.4. 堆排序（Heap Sort） 1.5. 冒泡排序（Bubble Sort） 1.6. 快速排序（Quick Sort） 1.7. 归并排序（Merge Sort） 2. 小结 3. 参考资料 1. 常见的内部排序算法汇总-C++描述排序：将无序的元素序列，通过一定的方法按照关键字顺序排列的过程。排序分为内部排序和外部排序： 内部排序：整个排序过程不需要访问外存便能完成。 外部排序：整个序列的排序过程不可能在内存中完成，需要借助外存才能完成，通常参加排序的数据量很大。 若经过排序，元素之间的相对次序保持不变，则称这种排序算法是稳定的，否则称为不稳定的。 本文是对内部排序算法的总结。 下表给出了常见的排序算法的性能： 排序方法 平均情况 最好情况 最坏情况 辅助空间 稳定性 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(nlogn)$~$O(n^2)$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$~$O(n)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 注：本文的实现都是从小到大排序。如果要看直观的动态排序图，参考参考资料中对应的链接。 1.1. 插入排序（Insertion Sort）插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到$O(1)$的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法步骤： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$。 稳定性：稳定 优化：如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，称为二分插入排序（代码略，以后补充）。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * 内部排序算法：插入排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 插入排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void insertSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 1; i &lt; n; ++i)&#123; T temp = vec[i]; // 保存第i个元素 int j = i-1; // 第i个元素之前的序列从右向左比较 for (; j &gt;= 0; --j)&#123; if (vec[j] &gt; temp) vec[j+1] = vec[j]; // 如果大于temp，则将该元素后移一位 else break; // 否则不移动，退出 &#125; vec[j+1] = temp; // 将temp赋值给第j+1个元素 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); insertSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.2. 希尔排序（Shell Sort）希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 算法步骤：希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。 例如，假设有这样一组数${13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10}$，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：${10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45}$.这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了）。 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 Donald Shell最初建议步长选择为$n/2$，并且对步长取半直到步长达到1。（本文如下代码既是采用这种方法实现） 时间复杂度：最好的时间复杂度为$O(n)$，而最坏时间复杂度和平均时间复杂度都要根据步长序列的不同而不同。 空间复杂度：$O(n)$ 稳定性：不稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 内部排序算法：希尔排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 希尔排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void shellSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); T temp; for (int step = n &gt;&gt; 1; step &gt; 0; step &gt;&gt;= 1)&#123; for (int i = step; i &lt; n; ++i)&#123; T temp = vec[i]; int j = i - step; for (; j &gt;= 0; j -= step)&#123; if (vec[j] &gt; temp) vec[j+step] = vec[j]; else break; &#125; vec[j+step] = temp; &#125; &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); shellSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.3. 选择排序（Selection Sort）选择排序（Selection sort）是一种简单直观的排序算法。 算法步骤：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n^2)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：不稳定 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 内部排序算法：选择排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 选择排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void selectSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 0; i &lt; n; ++i)&#123; int min = i; for (int j = i + 1; j &lt; n; ++j)&#123; if (vec[j] &lt; vec[min]) min = j; &#125; if (min != i) swap(vec[i], vec[min]); &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); selectSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.4. 堆排序（Heap Sort）堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆节点的访问：通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点$i$的左子节点在位置$2*i+1$; 父节点$i$的右子节点在位置$2*i+2$; 子节点$i$的父节点在位置${\lfloor}(i-1)/2{\rfloor}$; 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点； 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序； 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。 算法步骤： 创建一个最大堆heap[0:n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小1，并从根开始重新调整，使其成为一个堆； 重复步骤2~3，直到堆的尺寸为1。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：不稳定 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * 内部排序算法：堆排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 在vec中调整以root为根的子树 * @param: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') * @param: root: 调整以节点root为根的子树 * @param: n: 调整的的节点索引要小于n，即能调整到的最大编号 */template&lt;typename T&gt;void adjustHeap(vector&lt;T&gt;&amp; vec, int root, int n)&#123; if (root &gt;= n) return; while (2*root+1 &lt; n)&#123; // 左孩子存在 int child = 2*root+1; // 左孩子 if (2*root+2 &lt; n &amp;&amp; vec[2*root+2] &gt; vec[child]) child = 2*root+2; // 取以 root 节点为根的左右孩子值较大的那个 if (vec[child] &gt; vec[root]) // 如果孩子较大的那个比根还大，则交换它们 swap(vec[root], vec[child]); root = child; // 根元素的下沉过程 &#125;&#125;/* * @function: 堆排序，实现从小到大排序，构建最大堆 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void heapSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = (n&gt;&gt;1)-1; i &gt;= 0; --i) // 将待排序序列先调整为一个最大堆 adjustHeap(vec, i, n); for (int i = n-1; i &gt; 0; --i)&#123; swap(vec[0], vec[i]); // 将根元素与最后一个未排序的元素交换 adjustHeap(vec, 0, i); // // 重新调整以根结点的堆，调整的长度为未排序的长度 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); heapSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.5. 冒泡排序（Bubble Sort）冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(n^2)$ $O(n)$ $O(n^2)$ 空间复杂度：总共$O(n)$，需要辅助空间$O(1)$ 稳定性：稳定。 优化：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。（代码略，以后补充） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 内部排序算法：冒泡排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 冒泡排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void bubbleSort(vector&lt;T&gt;&amp; vec)&#123; size_t n = vec.size(); for (int i = 0; i &lt; n-1; ++i)&#123; bool flag = false; // 标志位，判断一次冒泡中是否有交换 for (int j = 0; j &lt; n-i-1; ++j)&#123; if (vec[j] &gt; vec[j+1])&#123; swap(vec[j], vec[j+1]); // 冒泡 flag = true; // 有交换，置flag为true &#125; &#125; if (!flag) break; // 如果没有交换，则说明剩下的元素已经是有序的，此时可直接退出循环 &#125;&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); bubbleSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.6. 快速排序（Quick Sort）快速排序（Quicksort），又称划分交换排序（partition-exchange sort），是一种排序算法，它使用分治法策略来把一个序列分为两个子序列。它通常明显比其他$O(nlogn)$算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 算法步骤： 从数列中挑出一个元素，称为基准（pivot）； 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 【注】：基准的选择可以选择数列的第一个元素或者最后一个元素或者中间的元素，更好的是选择这三个特殊元素按大小排列后，位于中间的那个元素。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ 空间复杂度：根据实现的方式不同而不同。 稳定性：不稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 内部排序算法：快速排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 将vec按照vec[low]元素的值分为左右两部分，左边的元素值都比vec[low]小，右边的元素值都比vec[high]大 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 * @return: 基准值所在的索引 */template&lt;typename T&gt;int partition(vector&lt;T&gt;&amp; vec, int low, int high)&#123; int pivotKey = vec[low]; while (low &lt; high)&#123; while (low &lt; high &amp;&amp; vec[high] &gt;= pivotKey) --high; swap(vec[low], vec[high]); while (low &lt; high &amp;&amp; vec[low] &lt;= pivotKey) ++low; swap(vec[low], vec[high]); &#125; return low;&#125;/* * @function: 用快速排序算法将vec序列中从low到high的子序列排序 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 */template&lt;typename T&gt;void qSort(vector&lt;T&gt;&amp; vec, int low, int high)&#123; if (low &lt; high)&#123; int pivot = partition(vec, low, high); qSort(vec, low, pivot-1); qSort(vec, pivot+1, high); &#125;&#125;/* * @function: 快速排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void quickSort(vector&lt;T&gt;&amp; vec)&#123; qSort(vec, 0, vec.size()-1);&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); quickSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 1.7. 归并排序（Merge Sort）归并排序（Merge Sort），是创建在归并操作上的一种有效的排序算法，效率为$O(nlogn)$。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。 归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 该算法可通过迭代法和递归法两种方法实现。 递归法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 迭代法步骤： 将序列每相邻两个数字进行归并操作，形成${\lceil}n/2{\rceil}$个序列，排序后每个序列包含两个元素； 将上述序列再次归并，形成${\lceil}n/4{\rceil}$个序列，每个序列包含四个元素； 重复步骤2，直到所有元素排序完毕。 时间复杂度： 平均时间复杂度 最好时间复杂度 最坏时间复杂度 $O(nlogn)$ $O(n)$ $O(nlogn)$ 空间复杂度：$O(n)$。 稳定性：稳定。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* * 内部排序算法：归并排序（递归实现） */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* * @function: 重载&lt;&lt;操作符 * @param: out: 输出流 * @parma: vec: 待输出的向量 * @return: 输出流 */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i) out &lt;&lt; vec[i] &lt;&lt; ' '; return out;&#125;/* * @function: 将vec[low:mid]和vec[mid+1:high]两部分合并为一个向量 * @param: vec: 待排序的序列 * @param: low: 第一个待排序序列的最左端的索引 * @param: mid: 第一个待排序序列的最右端的索引 * @param: high: 第二个待排序序列的最右端的索引 */template&lt;typename T&gt;void merge(vector&lt;T&gt;&amp; vec, int low, int mid, int high)&#123; int i = low, m = mid; int j = mid+1, n = high; vector&lt;T&gt; tempVec(high-low+1); int index = 0; while (i &lt;= m &amp;&amp; j &lt;= n)&#123; tempVec[index++] = (vec[i]&lt;=vec[j]) ? vec[i++] : vec[j++]; &#125; while (i &lt;= m)&#123; tempVec[index++] = vec[i++]; &#125; while (j &lt;= n)&#123; tempVec[index++] = vec[j++]; &#125; for (int k = 0; k &lt; tempVec.size(); ++k) vec[low++] = tempVec[k];&#125;/* * @function: 用归并排序算法将vec序列中从low到high的子序列排序 * @param: vec: 待排序的序列 * @param: low: 待排序序列的最左端的索引 * @param: high: 待排序序列的最右端的索引 */template&lt;typename T&gt;void mSort(vector&lt;T&gt;&amp; vec, int low, int high)&#123; if (low &lt; high)&#123; int mid = low + (high-low)/2; mSort(vec, low, mid); mSort(vec, mid+1, high); merge(vec, low, mid, high); &#125;&#125;/* * @function: 归并排序，实现从小到大排序 * @parma: vec: 待排序的序列，类型T必须定义（重载）了关系运算符('&lt;'或'&gt;') */template&lt;typename T&gt;void mergeSort(vector&lt;T&gt;&amp; vec)&#123; mSort(vec, 0, vec.size()-1);&#125;int main(int argc, char** argv)&#123; int arr[] = &#123;8, 6, 9, 2, 4, 1, 3, 0, 7, 5&#125;; int n = sizeof(arr)/sizeof(int); vector&lt;int&gt; vec(arr, arr+n); mergeSort(vec); cout &lt;&lt; vec &lt;&lt; endl; return 1;&#125; 代码输出：10 1 2 3 4 5 6 7 8 9 2. 小结上述排序算法可分类如下： 插入排序类：插入排序，希尔排序 选择排序类：选择排序，堆排序 交换排序类：冒泡排序，快速排序 归并排序类：归并排序 3. 参考资料 维基百科：插入排序 维基百科：希尔排序 维基百科：选择排序 维基百科：堆排序 维基百科：冒泡排序 维基百科：快速排序 维基百科：归并排序]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>内部排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL笔记之heap]]></title>
    <url>%2F2017%2F08%2F11%2FC-STL%E7%AC%94%E8%AE%B0%E4%B9%8Bheap%2F</url>
    <content type="text"><![CDATA[1. STL笔记之heap 1.1. 简介 1.2. 相关算法的使用 1. STL笔记之heap1.1. 简介heap（堆）是一种比较复杂的数据结构。不过 STL 已经封装了 heap 的一些操作，比如：创建堆、判断堆、插入一个元素、删除一个元素、以及堆排序。在 STL 中，heap 是以算法的形式提供的，包括下面几个函数： make_heap()：根据指定的迭代器区间以及一个可选的比较函数（通常为 greater&lt;T&gt;() 或者 less&lt;T&gt;()，其中 T 为一种数据类型），来创建一个 heap，时间复杂度为 O(n)； push_heap()：把指定区间的最后一个元素插入到 heap 中，时间复杂度为 O(logn)； pop_heap()：弹出 heap 顶元素，将其放置于区间末尾，时间复杂度 O(logn)； sort_heap()：堆排序算法，将指定区间的元素进行堆排序，时间复杂度为 O(nlogn)。 C++11 加入了两个新成员： is_heap()：判断给定区间是否是一个 heap，时间复杂度为 O(n)； is_heap_until()：找出区间中第一个不满足 heap 条件的元素，返回指向该元素的指针。时间复杂度为 O(n)。 因为 heap 都是以算法的形式提供，所以使用这几个函数需要包含如下头文件：1#include &lt;algorithm&gt; 1.2. 相关算法的使用使用数组来存储一个堆，也就是堆化数组：123int arr[] = &#123;2, 14, 4, 16, 6, 5, 3&#125;;vector&lt;int&gt; vec(arr, arr + sizeof(arr)/sizeof(int));// vector&lt;int&gt; vec&#123;2, 14, 4, 16, 6, 5, 3&#125;; 注：下述函数的使用都是代码片段，且使用的比较函数都是 greater&lt;T&gt;()，即小根堆，默认的是 less&lt;T&gt;()，即大根堆。完整代码在本文最后。 1. is_heap()：判断堆 原型：1234567// 1template&lt; typename RandomIt &gt;bool is_heap( RandomIt first, RandomIt last );// 2template&lt; typename RandomIt, typename Compare &gt;bool is_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1cout &lt;&lt; is_heap(vec.begin(), vec.end()) &lt;&lt; endl; 2. is_heap_until()：找出区间中第一个不满足 heap 条件的元素，返回指向该元素的指针。 原型：1234567// (1) (since C++11)template&lt; class RandomIt &gt;RandomIt is_heap_until( RandomIt first, RandomIt last );// (2) (since C++11)template&lt; class RandomIt, class Compare &gt;RandomIt is_heap_until( RandomIt first, RandomIt last, Compare comp ); 用法示例：12vector&lt;int&gt;::iterator iter = is_heap_until(vec.begin(), vec.end(), greater&lt;int&gt;());cout &lt;&lt; "is heap until: " &lt;&lt; *iter &lt;&lt; endl; 3. make_heap()：构造堆 STL 中的通过 make_heap() 创建的堆，默认是大根堆（max heap）。要改变堆的建立准则，可以自己制定一个比较函数，比如如下第二个版本的第三个参数。第三个参数可填：less&lt;int&gt;() 构造大根堆，greater&lt;int&gt;() 构造小根堆。（注意：要使用其中一个比较函数，在该堆上使用的其他算法也要使用该比较函数） 原型：1234567// 1template&lt; class RandomIt &gt;void make_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void make_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1make_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 4. push_heap()：插入元素 如果要在堆中插入一个元素，首先要往容器 vector 尾部插入一个元素，然后把新的迭代区间传给 push_heap()，这样新的元素也被插入到堆中。时间复杂度为 O(logn)。 原型：1234567// 1template&lt; class RandomIt &gt;void push_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void push_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：12vec.push_back(20);push_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 5. pop_heap()：弹出元素 弹出的元素默认是根节点的元素。这个算法的作用是交换根结点元素与堆中的最后一个元素，然后把除了尾部元素的剩余区间重新调整成堆。注意，pop_heap() 函数并没有真正的删除元素，最后要使用容器的 pop_back() 来删除元素。 原型：12345678910// 1 template&lt; class RandomIt &gt;void pop_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void pop_heap( RandomIt first, RandomIt last, Compare comp );// Swaps the value in the position first and the value in the position last-1 and makes the subrange [first, last-1) into a max heap. // This has the effect of removing the first (largest) element from the heap defined by the range [first, last). 用法示例：12pop_heap(vec.begin(), vec.end(), greater&lt;int&gt;());vec.pop_back(); 6. sort_heap()：堆排序 该算法实现经典的堆排序算法，通过每次弹出堆顶元素直到堆为空，依次被弹出的元素就组成了有序的序列。STL 中的 priority_queue 既是用 heap 的这个特性来实现的。 注意：使用 sort_heap() 时要确保区间已经是一个堆了，处理过后的区间因为有序，就不再是一个 heap 了。 原型：1234567// 1template&lt; class RandomIt &gt;void sort_heap( RandomIt first, RandomIt last );// 2template&lt; class RandomIt, class Compare &gt;void sort_heap( RandomIt first, RandomIt last, Compare comp ); 用法示例：1sort_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); 7. 完整代码示例：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out, vector&lt;T&gt;&amp; vec)&#123; for (int i = 0; i &lt; vec.size(); ++i)&#123; out &lt;&lt; vec[i] &lt;&lt; ' '; &#125; return out;&#125;int main(int argc, char **argv)&#123; // int arr[] = &#123;2, 14, 4, 16, 6, 5, 3&#125;; // vector&lt;int&gt; vec(arr, arr + sizeof(arr)/sizeof(int)); vector&lt;int&gt; vec&#123;2, 14, 4, 16, 6, 5, 3&#125;; cout &lt;&lt; "is heap: " &lt;&lt; is_heap(vec.begin(), vec.end()) &lt;&lt; endl; make_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "make heap: " &lt;&lt; vec &lt;&lt; endl; vec.push_back(20); push_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "push heap: " &lt;&lt; vec &lt;&lt; endl; pop_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); vec.pop_back(); cout &lt;&lt; "pop heap: " &lt;&lt; vec &lt;&lt; endl; sort_heap(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "sort heap: " &lt;&lt; vec &lt;&lt; endl; vector&lt;int&gt;::iterator iter = is_heap_until(vec.begin(), vec.end(), greater&lt;int&gt;()); cout &lt;&lt; "is heap until: " &lt;&lt; *iter &lt;&lt; endl; return 0;&#125; 代码输出为（注意，g++ 编译时需要添加 -std=c++11）：123456is heap: 0make heap: 2 6 3 16 14 5 4push heap: 2 6 3 16 14 5 4 20pop heap: 3 6 4 16 14 5 20sort heap: 20 16 14 6 5 4 3is heap until: 16]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++之回调函数]]></title>
    <url>%2F2017%2F08%2F11%2FC-c-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. c++之回调函数 1.1. 回调函数 1.2. c++中回调函数的使用 1. c++之回调函数1.1. 回调函数回调函数就是在调用某个函数B时，将自己的一个函数A的地址作为参数传递给函数B，函数B在执行的过程中，通过那个函数指针参数反过来调用函数A，即被调用者回头调用调用者的函数，故其称为回调函数（callback function）。 比如一般的API提供方无法知道用户会怎样使用数据，它就会让用户自己设计处理数据的函数，并将该函数的地址作为参数传递给API接口，API接口获取数据后调用传递给它的函数来实现用户自定义的数据处理方式。即用户调用服务方的API接口，它又反过来调用用户自定义的函数。 1.2. c++中回调函数的使用在C语言中可像普通函数一样使用回调函数，只须把回调函数定义为全局的即可。而在C++中的类成员函数中使用回调函数会发生错误。这是因为普通的C++成员函数都隐含了一个传递函数作为参数，即this指针，C++通过传递this指针给其成员函数从而实现成员函数的调用（每个成员函数都需要一个对象去调用它）。由于this指针的作用，使得将一个callback型的成员函数作为回调函数时就会因为隐含的this指针使得函数参数个数不匹配，从而导致回调函数调用失败。（我的理解是：如果在API提供方提供的函数中调用类的成员函数，必需传递一个类的实例的指针，通过这个类的实例指针来调用该成员函数，否则在类外无法在没有类实例的情况下直接调用其成员函数）。 要解决这一问题，有三种方法： 1. 不使用成员函数，即将回调函数定义为全局的，像C语言一样使用回调函数（这样有个问题就是无法访问类的成员变量）： 代码示例如下：&#123;.line-numbers&#125;12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;//---------------------------------// 这个是回调函数void callbackFun(int a)&#123; cout &lt;&lt; "callbackFun: " &lt;&lt; a &lt;&lt; endl;&#125;class testClass&#123;public: void start(pFun f, int a)&#123; fun(f, a); &#125;private:&#125;;int main()&#123; fun(callbackFun, 10); // C 的用法 testClass aaa; aaa.start(callbackFun, 6); // 在类中调用全局的回调函数 return 1;&#125; 代码输出：12callbackFun: 10callbackFun: 6 2. 不使用成员函数，为了访问类的成员变量，使用友元操作符(friend)，在C++中将该函数说明为类的友元即可。 代码示例如下：&#123;.line-numbers&#125;12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);void callbackFun(int); // 回调函数声明// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;// 测试类class testClass&#123;public: testClass(int a) : m(a) &#123;&#125; friend void callbackFun(int a); // 友元private: int m;&#125;;//---------------------------------// 这个是回调函数void callbackFun(int a)&#123; testClass aaa(a); cout &lt;&lt; "callbackFun aaa.m: " &lt;&lt; aaa.m &lt;&lt; endl; // 访问类的私有成员&#125;int main()&#123; fun(callbackFun, 10); return 1;&#125; 代码输出：1callbackFun aaa.m: 10 3. 回调函数必需是类的成员函数，将其设计为静态成员函数，静态成员函数不使用this指针作为隐含变量，这样就可以作为回调函数了。但这样有一个严重的缺点：静态成员函数只能访问类的静态成员变量和静态成员函数，不能访问非静态的。可以通过设计一个静态类指针作为类成员来解决，通过在类创建时初始化该静态指针，然后在回调函数中通过该静态指针来访问所有成员变量和成员函数了。 代码示例如下：&#123;.line-numbers&#125;123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef void (*pFun)(int);// 假设是 API 接口void fun(pFun fun, int a)&#123; fun(a);&#125;class testClass&#123;public: testClass(int a) : m(a) &#123;&#125; // 回调函数 static void callbackFun(int a)&#123; cout &lt;&lt; "callbackFun a: " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "m: " &lt;&lt; pTestClass-&gt;m &lt;&lt; endl; &#125; void start(pFun f, int a)&#123; pTestClass = this; // 将该this指针赋给静态类指针 fun(f, a); &#125;private: int m; static testClass* pTestClass; // 静态类指针&#125;;testClass* testClass::pTestClass = NULL;int main()&#123; testClass aaa(10); aaa.start(testClass::callbackFun, 6); return 1;&#125; 代码输出：12callbackFun a: 6m: 10 但是上述方法只能适用于一个实例的情况，因为多个实例将共享静态成员变量。为了避免这种情况，可以使用回调函数的一个参数来传递this指针，从而实现数据成员共享。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-Face Image Quality Assessment Based on Learning to Rank(by Jiansheng Chen)]]></title>
    <url>%2F2017%2F07%2F13%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Face-Image-Quality-Assessment-Based-on-Learning-to-Rank-JianshengChen%2F</url>
    <content type="text"><![CDATA[1. 摘要 1.1. 介绍 1.2. 人脸标准化 1.3. 人脸质量评价 1.4. 实验 1.5. 总结 2. 参考文献 1. 摘要人脸图像质量是人脸识别准确性的重要影响因素之一。在实际识别系统中通常会抓取到不同场景下的多张人脸，从多张人脸图像中选择一张高质量图像去识别对提高系统的性能是非常有用的策略。本文提出了一种基于 learning to rank 的框架去评估人脸图像质量。这种方法很简单，并且能够自适应不同的识别方法。实验结果证明了它在提高人脸检测及识别的鲁棒性上非常有效。 关键字：人脸质量，人脸识别，learing to rank 1.1. 介绍对个人身份验证来说，人脸被普遍认为是一种理想的生物识别特征，因为它是普遍的、有区别的、非侵入式的并且容易获取。在过去的二十年，自动人脸识别技术吸引了大量的关注，不管是学术界还是工业界，提出了很多基于人脸图像的人脸识别 (identifying) 和身份认证 (verifying) 方法。然而，人脸识别仍是一项富有挑战性的任务，因为在自然环境下采集的人脸图像会由于光照、姿态、遮挡、表情的不同产生不同的图像。这些问题在实际的应用程序中会由于不配合的用户以及不可控的环境造成非常严重的影响。虽然很多提出了很多方法来提高人脸识别的鲁棒性去对抗不同质量的人脸图像，但普遍认为人脸识别还是在高质量人脸图像上表现出更好的性能。 1.2. 人脸标准化仅仅位于人脸内部的像素点应该用来评估人脸质量。这可以实现，比如，通过定位人脸轮廓的标志点，图像中的每张脸可以产生一个特殊的标注。然而，这很耗时，并且由于不规则的轮廓，对后面的特征提取造成很大的困难。另一方面，许多人脸检测器简单的输出方形包围框，这明显偏离了人脸的轮廓，并且涵盖了大量的非人脸信息。此外，面部旋转也应该作为质量评估的影响因素之一，因为很多人脸识别系统都能够处理。基于上述所有的考虑，本文提出了人脸标准化过程，见 Fig.1. Fig.1(a) 展示了人脸检测的结果，该人脸来自 LFW 人脸数据集。然后将检测到的人脸区域调整到 $68\times68$ 像素，输入一个 CNN 网络来获取标志点位置。本文用眼角和嘴角，因为这些点可以清晰的标注，并且涵盖的区域包含了人脸的大部分区域。Fig.2 展示了 CNN 的网络结构，它包含了三个卷积层以及三个降采样层，卷积核是 $5\times5$，输出是标志点坐标。本文从 LFW 数据集中随机选择了 10000 幅图像用来训练，剩下的用来测试。在测试集上，标志点的位置偏差平均是 1.4 个像素。Fig.1(b) 显示了标注的标志点。 为了标准化人脸区域，并且消除旋转的影响，本文首先计算中心点 $C$ 以及用 linear time algorithm 方法得到的涵盖所有标志点的最小的圆的半径 $r$。然后以点 $C$ 为中心取一个大小为 $2.4r\times4r$ 的矩形 $R$ (见图Fig.1(c))。显然所有的标志点都包含在 $R$ 中。设四个眼角的坐标是 $[x_i, y_i], (i = 1,2,3,4)$，矩形的方向由公式 $(1)$ 决定，这样矩形 $R$ 的宽平行于四个眼角构成的直线。Fig.1(d) 中的标准脸就可以由矩形区域 $R$ 围绕 $C$ 旋转 $\theta$ 角得到。 $$\theta = \arctan(\frac{\sum_{i=1}^{4} {x_iyi} - 4\overline{x}\overline{y}}{\sum{i=1}^{4} {x_i^2} - 4{\overline{x}}^2})$$(1) 其中 $\overline{x}$ 和 $\overline{y}$ 分别表示水平和垂直方向的均值。 更多的 LFW 图像的标准化结果如图 Fig.1(e)(f)(g)，可以看到标准化的脸更紧凑，并确保包含了人脸的主要部分。标准化过后的脸之后被用于人脸质量评估的输入。这个标准化方法对于一些不准确的标志点来说是有点健壮的。然而，当出现多个标志点位置不准确的情况，标准化的结果可能会恶化，并导致人脸质量评估的结果效果很差。然而这个问题是可以容忍的，因为这大多数情况下，这种情况确实表明人脸图像的质量很低。 1.3. 人脸质量评价一般很难精确的定义量化人脸图像质量。在过去的研究中，解决此问题主要有两种方案。第一种是利用面部的一些特性，比如分辨率、姿态角度、或者光照参数，利用这些去量化人脸图像质量；另一种是选择一张“标准脸”，用人脸图像与这张“标准脸”的差异来度量人脸质量。这两种方法都比较僵化，缺乏适用性，因为它们都没有考虑人脸识别方法可能带来的差异。比如有一种人脸识别算法适用于解决遮挡问题，那么 Fig.1(g) 可能比 Fig.1(f) 表现的更好。相反的，有一种人脸识别算法适用于解决姿态问题，则 Fig.1(f) 具有更高的图像质量。因此，要以相对的方式去考虑人脸图像质量。对大多数人脸识别方法，考虑图像质量，Fig.1(d) 比 Fig.1(f) 要好，但是比 Fig.1(e) 要差。 基于上述的考虑，本文提出了一种基于 learning to rank 的简单的、灵活的人脸图像质量评价方法。假设有一种人脸识别方法在两个不同的数据集 $A$ 和 $B$ 中测试，且识别的性能在 $A$ 上表现比 $B$ 好。这表明，对这种人脸识别方法，$A$ 中的图像比 $B$ 中的有更高的质量。我们标记这为 $A\succ B$，设 $I_i$ 和 $I_j$ 分别表示 $A$ 和 $B$ 中的一幅图像，$f()$ 表示将提取图像特征向量的函数，定义一种线性结构的质量评价函数 $S(I) = \omega^{T}f(I)$，目标就是求权重 $\omega$ 的值，使得其满足方程 $(2)$ 的约束。同时，在同一个人脸数据集中的图像应该具有相同的质量，这通过方程 $(3)\;(4)$ 来约束，本文称 $S(I)$ 的值为图像 $I$ 的 $RQS(Rank \; based \; Quality \; Score)$。 $$\omega^{T}f(I_i) &gt; \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{B}$$(2)$$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{A},\;\forall{I_j}\in{A}$$(3)$$\omega^{T}f(I_i) = \omega^{T}f(I_j);\quad \forall{I_i}\in{B},\;\forall{I_j}\in{B}$$(4) 上述问题规划与文献 [23] 中的相同，因此可以转化为一个凸规划问题（见公式(5)），通过引入非负松弛变量 ${\lambda_1},\,{\lambda_2},\,{\lambda_3}$ 来平衡相关约束，由公式 (5) 定义的优化问题可以用 Newton 方法有效的解决。 $$minmize(|{\omega^T}|_2^2 + {\lambda1}{\sum{\xi{ij}^2}} + {\lambda2}{\sum{\eta{ij}^2}} + {\lambda3}{\sum{\gamma{ij}^2}})$$$$s.t.\quad {\omega^T(f(I_i)-f(Ij))}\geq{1-\xi{ij}};\quad{\forall{I_i}\in{A},\,{\forall{I_j}\in{B}}}$$$${|\omega^T(f(I_i)-f(Ij))|}\leq{\eta{ij}},\quad{\forall{I_i}\in{A},\,{\forall{I_j}\in{A}}}$$$${|\omega^T(f(I_i)-f(Ij))|}\leq{\gamma{ij}},\quad{\forall{I_i}\in{B},\,{\forall{Ij}\in{A}}}$$$${\xi{ij}}\geq{0},\quad {\eta{ij}}\geq{0},\quad {\gamma{ij}}\geq{0}$$(5) 本文提出的公式可以扩展至多数据集、多特征。对于多特征融合，采用两层学习策略。假设从图像 $I$ 中提取了 $m$ 个不同的特征，设与第 $i$ 个特征相关的质量评价函数为 $S_i(I)={\omega^T}f_i(I),\;{(i=1,2,\cdots,m)}$。在第一层学习中，所有的排序权重 $\omega_i$ 通过公式(5)学习到，设 $\vec{S_v} = {[{S_1(I)};{S_2(I)}\;\cdots\;{S_m(I)}]}^T$ 为包含第一层学习张由图像 $I$ 所有特征得到的 $RQS$ 的列向量。定义第二层质量评估函数为 ${S_k(I)} = {\omegak}{f{\Phi}(\vec{Sv})}$，其中 $f{\Phi}()$ 为多项式核函数。本文中 $m=5$ 并且多项式核函数为二阶多项式核函数。$f_{\Phi}(\vec{S_v})$ 的表达式为公式(6)。 $\omega_k$ 的值可以通过二次训练得到，$S_k(I)$ 的值归一化到 $0~100$ 之间，并用来图像 $I$ 的最终得分。Fig.3 展示了计算 Fig.1(d) 的 $RQS$ 的计算过程。 1.4. 实验本文实验结果展示如图Fig.6。 1.5. 总结2. 参考文献]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人脸图片质量评估]]></title>
    <url>%2F2017%2F07%2F12%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%BA%E8%84%B8%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[1. 人脸图片质量评估 1.1. 参考资料 1. 人脸图片质量评估图片质量评估 算法分为：主观的和客观的。 人脸识别系统 的流程为：输入面部图片–&gt;人脸检测–&gt;质量评估–&gt;对质量较好的进行识别(不好的丢弃) 人脸图片质量特征 纹理特征(Texture)：对比度(Contrast)，压缩比(Compression ratio)，光照强度(Illuminance) 几何特征(Geometry)：对称性(Symmetry)，姿态(Pose)，旋转角度(Rotation)，双眼之间的距离(Eye visibility) 人脸图片质量评估 是基于排序学习(Learning to rank, 简称 L2R)。 1.1. 参考资料 Vladimir Khryashchev, Evaluation of Face Image Quality Metrics in Person Identification Problem Jiansheng Chen, Member, IEEE, Yu Deng, Gaocheng Bai, and Guangda Su, Face Image Quality Assessment Based on Learning to Rank]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人脸质量评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt 界面样式设计]]></title>
    <url>%2F2017%2F07%2F06%2FC-Qt-%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1. Qt 界面样式设计 1.1. 控件样式设计 1.1.1. QLabel 样式 1.1.2. QComboBox 1.1.3. QEditLine 1.1.4. QCheckbox 1.1.5. QPushButton 1.1.6. QScrollBar 1.1.7. QTableWidget 1.2. 参考资料 1. Qt 界面样式设计1.1. 控件样式设计改变控件的样式一般使用 setStyleSheet(“”) 函数，其可填参数如下： 参数 效果说明 “background-color: rgb(0, 0, 0);” 设置 件的背景色为 QColor(0,0,0) “background: url(:/img/label_bg.png);” 用图片填充控件 “color: rgb(255, 255, 255);” 设置控件的文本颜色为 QColor(255,255,255) “font: bold 16px;” 设置控件中的文本字体为 16 号粗体 “border: 2px solid rgb(66, 169, 235);” 设置控件的边框宽度为 2px，颜色为 QColor(66,169,235) “border-radius: 4px;” 设置控件的边角为圆角 以下仅对具体控件的特殊样式设计进行说明。 1.1.1. QLabel 样式如果 style sheet 无法满足 QLabel 在应用的需求，可通过继承 QLabel 写自己新的 label 类。比如在 QLabel 的四个角画线，显示一种画框效果，可新建一个 MyQLabel 类，在类中重写 paintEvent(QPaintEvent *event) 函数即可。代码示例如下： 1234567891011121314151617181920void MyQLabel::paintEvent(QPaintEvent *event)&#123; QLabel::paintEvent(event); // 重要，先调用父类的 paintEvent() 为了显示原背景图像 int width = this-&gt;width(); int height = this-&gt;height(); QPainter painter(this); painter.setPen(QPen(QColor(66,169,235), 3)); painter.drawLine(QPointF(0, 0), QPointF(width/8, 0)); // 左上角横线 painter.drawLine(QPointF(0, 0), QPointF(0, height/8)); // 左上角竖线 painter.drawLine(QPointF(width, 0), QPointF(width*7/8, 0)); // 右上角横线 painter.drawLine(QPointF(width, 0), QPointF(width, height/8)); // 右上角竖线 painter.drawLine(QPointF(0, height), QPointF(width/8, height)); // 左下角横线 painter.drawLine(QPointF(0, height), QPointF(0, height*7/8)); // 左下角竖线 painter.drawLine(QPointF(width, height), QPointF(width*7/8, height)); // 右下角横线 painter.drawLine(QPointF(width, height), QPointF(width, height*7/8)); // 右下角竖线&#125; 效果如下（图中的照片是一张背景图）： 1.1.2. QComboBox参考链接：Qt Style Sheet实践（二）：组合框QComboBox的定制 1.1.3. QEditLine一般用 QEditLine 控件实现搜索框。 12345678910111213141516171819query_button = new QPushButton();query_button-&gt;setFixedWidth(50);query_button-&gt;setCursor(Qt::PointingHandCursor);query_button-&gt;setToolTip(tr("搜索"));// query_button-&gt;setFlat(true); // 实现按钮透明query_button-&gt;setStyleSheet("QPushButton&#123;background:url(:/button/button_search) center no-repeat; border: none;&#125;");query_edit = new QLineEdit();query_edit-&gt;setFixedWidth(530);query_edit-&gt;setPlaceholderText(tr("请输入要搜索的id"));query_edit-&gt;setStyleSheet("background-color: rgb(29,33,41); color: rgb(255,255,255); height: 35px; border: 1px solid rgb(66,169,235); border-radius: 6px;");QMargins margins = query_edit-&gt;textMargins(); // 设置文本与搜索框的边距，避免太靠近query_edit-&gt;setTextMargins(margins.left(), margins.top(), query_button-&gt;width(), margins.bottom());QHBoxLayout *query_edit_layout = new QHBoxLayout(); // 设置 query_edit 的布局query_edit_layout-&gt;addStretch();query_edit_layout-&gt;addWidget(query_button);query_edit_layout-&gt;setSpacing(0);query_edit_layout-&gt;setContentsMargins(0, 0, 5, 0);query_edit-&gt;setTextMargins(8, 0, 0, 0);query_edit-&gt;setLayout(query_edit_layout); 效果如下： 其他的样式设计可参考：Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全 1.1.4. QCheckbox 参数 效果说明 “QCheckBox::indicator {width: 20px; height: 20px;}” 设置勾选框的大小 “QCheckBox::indicator:unchecked {image: url(:/checkbox/unchecked);}” 设置勾选框未勾选时的效果 “QCheckBox::indicator:unchecked:hover {image: url(:/checkbox/unchecked_hover);}” 设置勾选框未勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:unchecked:pressed {image: url(:/checkbox/unchecked_press);}” 设置勾选框未勾选时鼠标点击状态下的效果 “QCheckBox::indicator:checked {image: url(:/checkbox/checked);}” 设置勾选框勾选时的效果 “QCheckBox::indicator:checked:hover {image: url(:/checkbox/checked_hover);}” 设置勾选框勾选时鼠标悬浮状态下的效果 “QCheckBox::indicator:checked:pressed {image: url(:/checkbox/checked_press);}” 设置勾选框勾选时鼠标点击状态下的效果 1.1.5. QPushButtonQPushButton 的独特的样式如下： 参数 效果说明 “QPushButton{background-color: rgb(66,169,235);}” 设置正常状态下 QPushButton 的背景色 “QPushButton:hover{background-color: rgb(60,195,245);}” 设置鼠标悬浮状态下 QPushButton 的背景色 “QPushButton:pressed{background-color: rgb(9,140,188);}” 设置鼠标点击状态下 QPushButton 的背景色 以上设置背景色的方法还可以改为设置图片，方法为：将 “background-color: rgb(66,169,235)” 改为 “border-image: url(:/pushbutton_normal.png)” 1.1.6. QScrollBar设置水平滚动条： 12345table_widget-&gt;horizontalScrollBar()-&gt;setStyleSheet("QScrollBar:horizontal&#123;background:rgb(32,36,45); padding-top:1px; padding-bottom:1px; padding-left:20px; padding-right:20px; border:1px solid rgb(38,42,53); height: 16px;&#125;" // 整体设置 "QScrollBar::handle:horizontal&#123;background:rgb(47,53,66); border-radius: 6px; border: 1px solid rgb(32,36,45);&#125;" // 设置滚动条 "QScrollBar::hadnle:horizontal:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:horizontal&#123;background:url(:/scrollbar/arrow_right) center on-repeat;&#125;" // 设置右箭头 "QScrollBar::sub-line:horizontal&#123;background:url(:/scrollbar/arrow_left) center no-repeat;&#125;"); // 设置左箭头 设置垂直滚动条： 12345table_widget-&gt;verticalScrollBar()-&gt;setStyleSheet("QScrollBar:vertical&#123;background:rgb(32,36,45); padding-top:20px; padding-bottom:20px; padding-left:1px; padding-right:1px; border:1px solid rgb(38,42,53); width: 16px;&#125;" // 整体设置 "QScrollBar::handle:vertical&#123;background:rgb(47,53,66); border-radius: 6px; border: none;&#125;" // 设置滚动条 "QScrollBar::hadnle:vertical:hover&#123;background:rgb(255,255,255); border-radius: 6px; border: none;&#125;" // 设置鼠标放到滚动条上的状态 "QScrollBar::add-line:vertical&#123;background:url(:/scrollbar/arrow_down) center on-repeat;&#125;" // 设置下箭头 "QScrollBar::sub-line:vertical&#123;background:url(:/scrollbar/arrow_up) center no-repeat;&#125;"); // 设置上箭头 QScrollBar 的一些样式属性说明： 1.1.7. QTableWidget设置表格样式： 123table_widget-&gt;setStyleSheet("selection-background-color: rgb(0, 120, 215)"); // 设置选中时的背景色table_widget-&gt;setStyleSheet("QWidget&#123;background-color: rgb(32,37,45)&#125;" // 设置普通状态下的背景色 "QTableWidget::item&#123;border-top: 1px solid rgb(38, 42, 53); border-bottom: 1px solid rgb(38, 42, 53)&#125;"); // 设置表格单元格 1.2. 参考资料 Qt Style Sheets Reference Qt Style Sheets Examples The Style Sheet Syntax Qt控件美化 Qt Style Sheet实践（一）：按钮及关联菜单 Qt Style Sheet实践（二）：组合框QComboBox的定制 Qt Style Sheet实践（三）：QCheckBox和QRadioButton Qt Style Sheet实践（四）：行文本编辑框QLineEdit及自动补全]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>界面样式</tag>
      </tags>
  </entry>
</search>